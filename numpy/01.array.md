- - -

# 넘파이 입문 : 배열

### NumPy Primer: Array

* * *

**박 진 수** 교수  
Intelligent Data Semantics Lab  
Seoul National University

- - -

<h3>Table of Contents<span class="tocSkip"></span></h3>
<div class="toc"><ul class="toc-item"><li><span><a href="#넘파이(NumPy)란?" data-toc-modified-id="넘파이(NumPy)란?-1">넘파이(NumPy)란?</a></span></li><li><span><a href="#넘파이-설치-및-사용" data-toc-modified-id="넘파이-설치-및-사용-2">넘파이 설치 및 사용</a></span></li><li><span><a href="#넘파이-배열(array)" data-toc-modified-id="넘파이-배열(array)-3">넘파이 배열(array)</a></span><ul class="toc-item"><li><span><a href="#파이썬-리스트와의-차이" data-toc-modified-id="파이썬-리스트와의-차이-3.1">파이썬 리스트와의 차이</a></span><ul class="toc-item"><li><span><a href="#1차원-더하기-연산" data-toc-modified-id="1차원-더하기-연산-3.1.1">1차원 더하기 연산</a></span></li><li><span><a href="#2차원-더하기-연산" data-toc-modified-id="2차원-더하기-연산-3.1.2">2차원 더하기 연산</a></span></li><li><span><a href="#1차원-곱하기-연산" data-toc-modified-id="1차원-곱하기-연산-3.1.3">1차원 곱하기 연산</a></span></li><li><span><a href="#2차원-곱하기-연산" data-toc-modified-id="2차원-곱하기-연산-3.1.4">2차원 곱하기 연산</a></span></li></ul></li></ul></li><li><span><a href="#배열-생성" data-toc-modified-id="배열-생성-4">배열 생성</a></span><ul class="toc-item"><li><span><a href="#array()-함수" data-toc-modified-id="array()-함수-4.1">array() 함수</a></span><ul class="toc-item"><li><span><a href="#1차원-배열" data-toc-modified-id="1차원-배열-4.1.1">1차원 배열</a></span></li><li><span><a href="#다차원-배열" data-toc-modified-id="다차원-배열-4.1.2">다차원 배열</a></span></li></ul></li><li><span><a href="#arange()-함수" data-toc-modified-id="arange()-함수-4.2">arange() 함수</a></span></li><li><span><a href="#내장함수" data-toc-modified-id="내장함수-4.3">내장함수</a></span><ul class="toc-item"><li><span><a href="#zeros()-함수" data-toc-modified-id="zeros()-함수-4.3.1">zeros() 함수</a></span></li><li><span><a href="#ones()-함수" data-toc-modified-id="ones()-함수-4.3.2">ones() 함수</a></span></li><li><span><a href="#full()-함수" data-toc-modified-id="full()-함수-4.3.3">full() 함수</a></span></li><li><span><a href="#eye()-함수" data-toc-modified-id="eye()-함수-4.3.4">eye() 함수</a></span></li><li><span><a href="#diag()-함수" data-toc-modified-id="diag()-함수-4.3.5">diag() 함수</a></span></li><li><span><a href="#random.random()-함수" data-toc-modified-id="random.random()-함수-4.3.6">random.random() 함수</a></span></li><li><span><a href="#random.randint()-함수" data-toc-modified-id="random.randint()-함수-4.3.7">random.randint() 함수</a></span></li><li><span><a href="#Lab:-랜덤-벡터-생성과-정렬" data-toc-modified-id="Lab:-랜덤-벡터-생성과-정렬-4.3.8">Lab: 랜덤 벡터 생성과 정렬</a></span></li></ul></li></ul></li><li><span><a href="#배열-자료형" data-toc-modified-id="배열-자료형-5">배열 자료형</a></span><ul class="toc-item"><li><span><a href="#형변환-메소드" data-toc-modified-id="형변환-메소드-5.1">형변환 메소드</a></span></li></ul></li><li><span><a href="#배열의-차원" data-toc-modified-id="배열의-차원-6">배열의 차원</a></span><ul class="toc-item"><li><span><a href="#차원(rank)-:-ndim" data-toc-modified-id="차원(rank)-:-ndim-6.1">차원(rank) : ndim</a></span></li><li><span><a href="#차원-형태-:-shape" data-toc-modified-id="차원-형태-:-shape-6.2">차원 형태 : shape</a></span></li><li><span><a href="#배열의-개수-:-size" data-toc-modified-id="배열의-개수-:-size-6.3">배열의 개수 : size</a></span></li><li><span><a href="#차원-변경-:-reshape()" data-toc-modified-id="차원-변경-:-reshape()-6.4">차원 변경 : reshape()</a></span></li><li><span><a href="#Lab:-벡터를-행렬로-변환하기" data-toc-modified-id="Lab:-벡터를-행렬로-변환하기-6.5">Lab: 벡터를 행렬로 변환하기</a></span></li><li><span><a href="#Lab:-대각행렬(diagonal-matrix)" data-toc-modified-id="Lab:-대각행렬(diagonal-matrix)-6.6">Lab: 대각행렬(diagonal matrix)</a></span></li></ul></li></ul></div>

# 넘파이(NumPy)란?

계산과학(computation science)분야에 자주 활용되는 파이썬 라이브러리다.
- 고성능의 다차원 배열(array) 객체와 이를 다룰 수 있는 다양한 도구를 지원한다.
    + Numpy의 내부가 상당 부분 C나 포트란으로 작성되어 있어 실행 속도도 꽤 빠르다.
- 기본적으로 배열(array)이라는 자료를 생성하고 이를 바탕으로 인덱싱 및 연산 처리 등을 편리하게 수행한다.
    + 난수생성, 푸리에변환, 행렬연산, 간단한 기술통계 분석 정도는 가능하지만 주로 scipy, pandas, matplotlib 등 다른 파이썬 패키지와 함께 쓰이는 경우가 많다.
- 문법이나 구동 방식이 MATLAB과 유사하다.
- Documentation
    + <https://docs.scipy.org/doc/> 

# 넘파이 설치 및 사용


```python
!python -m pip install --upgrade numpy
```

**import numpy**로 numpy를 불러와서 사용해야 한다.
- 주로 **import numpy as np**로 numpy를 불러와서, 짧게 *np*로 사용하는 경우가 많다.


```python
import numpy  # as np

# 버전을 확인한다.
print('NumPy version...:', numpy.__version__)  
```

    NumPy version...: 1.18.2


# 넘파이 배열(array)

- 넘파이(NumPy)의 핵심적인 객체이다.
- 배열은 "동일한 자료형을 가지는 값들이 격자판 형태로 있는 것"이다.
- 파이썬의 리스트(list)와 거의 비슷하나 배열은 동일한 자료형만 들어가야 한다는 차이가 있다.
- 사용 방법도 리스트와 유사하나 특성과 활용 가능한 함수 등이 다르다.
- 다차원(n-dimensional) 배열로 확장이 가능하다.

## 파이썬 리스트와의 차이

<font style='font-weight: bold; font-size: 115%'>NumPy array는 다차원 배열(matrix) 연산에 유용한다.</font>

### 1차원 더하기 연산


```python
# --- 1차원 
# 파이썬 1차원 리스트
L = list(range(1, 6)) 

# 넘파이 1차원 배열
arr = numpy.array(L)  

print(L)
print(arr)
```

    [1, 2, 3, 4, 5]
    [1 2 3 4 5]



```python
# --- 1차원 더하기 연산
# > L = [1, 2, 3, 4, 5]
# > arr = [1 2 3 4 5]
print(L + [10])       # 파이썬 리스트   
print(arr + 10)       # 넘파이 배열  
```

    [1, 2, 3, 4, 5, 10]
    [11 12 13 14 15]



```python
# --- 1차원 더하기 연산
# > L = [1, 2, 3, 4, 5]
# > arr = [1 2 3 4 5]
print(L + L)        # 파이썬 리스트   
print(arr + arr)    # 넘파이 배열  
```

    [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]
    [ 2  4  6  8 10]



```python
# --- 만약 리스트로 넘파이 배열과 같은 계산을 하려면...
# > arr = [1 2 3 4 5]
# > arr + arr => [2 4 6 8 10]
# > L = [1, 2, 3, 4, 5]
alist = []
for i in L:
  alist.append(i + i)
else:
  print(alist)
```

    [2, 4, 6, 8, 10]



```python
# --- 리스트 축약으로 하면...
# > arr = [1 2 3 4 5]
# > arr + arr => [2 4 6 8 10]
# > L = [1, 2, 3, 4, 5]
[(i + i) for i in L]
```




    [2, 4, 6, 8, 10]



### 2차원 더하기 연산


```python
# --- 2차원 
# 파이썬 2차원 리스트
L2 = [list(range(1, 6)), list(range(6, 11))]  

# 넘파이 2차원 배열
arr2 = numpy.arange(1, 11).reshape(2, 5) 

print(L2)
print(arr2)
```

    [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]
    [[ 1  2  3  4  5]
     [ 6  7  8  9 10]]



```python
# --- 2차원 더하기 연산
# > L2 = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]
# > arr2 = [[1 2 3 4 5] [6 7 8 9 10]]
print(L2 + L2)        # 파이썬 리스트
print(arr2 + arr2)    # 넘파이 배열
```

    [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]
    [[ 2  4  6  8 10]
     [12 14 16 18 20]]



```python
# --- 만약 리스트로 넘파이 배열과 같은 계산을 하려면...
# > arr2 = [[1 2 3 4 5] [6 7 8 9 10]]
# > arr2 + arr2 => [[2 4 6 8 10] [12 14 16 18 20]]
# > L2 = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]
list2 = []
for row in L2:
  tmp = []
  for column in row:
    tmp.append(column + column)
  else:
    list2.append(tmp)
else:
  print(list2)  
```

    [[2, 4, 6, 8, 10], [12, 14, 16, 18, 20]]



```python
# --- 리스트 축약으로 하면...
# > arr2 = [[1 2 3 4 5] [6 7 8 9 10]]
# > arr2 + arr2 => [[2 4 6 8 10] [12 14 16 18 20]]
# > L2 = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]
[[column + column for column in row] for row in L2]  
```




    [[2, 4, 6, 8, 10], [12, 14, 16, 18, 20]]



### 1차원 곱하기 연산


```python
# --- 1차원 곱하기 연산
# > L = [1, 2, 3, 4, 5]
# > arr = [1 2 3 4 5]
print(L * 2)     # 파이썬 리스트
print(arr * 2)   # 넘파이 배열
```

    [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]
    [ 2  4  6  8 10]



```python
# --- 만약 리스트로 위의 넘파이 배열과 같은 계산을 하려면...
# > arr = [1 2 3 4 5]
# > arr * 2 => [2 4 6 8 10]
# > L = [1, 2, 3, 4, 5]
alist = []
for i in L:
  alist.append(i * 2)
else:
  print(alist)
```

    [2, 4, 6, 8, 10]



```python
# --- 리스트 축약으로 하면...
# > arr = [1 2 3 4 5]
# > arr * 2 => [2 4 6 8 10]
# > L = [1, 2, 3, 4, 5]
[(i * 2) for i in L]
```




    [2, 4, 6, 8, 10]



### 2차원 곱하기 연산


```python
# --- 2차원 곱하기 연산
# > L2 = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]
# > arr2 = [[1 2 3 4 5] [6 7 8 9 10]]
print(L2 * 2)     # 파이썬 리스트
print(arr2 * 2)   # 넘파이 배열
```

    [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]
    [[ 2  4  6  8 10]
     [12 14 16 18 20]]



```python
# --- 만약 리스트로 위의 넘파이 배열과 같은 계산을 하려면...
# > arr2 = [[1  2  3  4  5] [6  7  8  9 10]]
# > arr2 * 2 => [[2 4 6 8 10] [12 14 16 18 20]]
# > L2 = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]
list2 = []
for row in L2:
  tmp = []
  for column in row:
    tmp.append(column * 2)
  else:
    list2.append(tmp)
else:
    print(list2)    
```

    [[2, 4, 6, 8, 10], [12, 14, 16, 18, 20]]



```python
# --- 리스트 축약으로 하면...
# > arr2 = [[1  2  3  4  5] [6  7  8  9 10]]
# > arr2 * 2 => [[2 4 6 8 10] [12 14 16 18 20]]
# > L2 = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]
[[column * 2 for column in row] for row in L2]
```




    [[2, 4, 6, 8, 10], [12, 14, 16, 18, 20]]



# 배열 생성

## array() 함수

**array()** 함수로 다차원 배열을 생성하여 배열 안의 배열로 차원을 구분한다.   

[numpy.array](https://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html?highlight=array#numpy.array)
- Create an array.
- numpy.**array**(*object, dtype=None, copy=True, order='K', subok=False, ndmin=0*)
    - ***object*** : *array_like*
        - An array, any object exposing the array interface, an object whose **\_\_array\_\_** method returns an array, or any (nested) sequence.

<!--
numpy.array(object, dtype=None, copy=True, order=’K’, subok=False, ndmin=0) 
- Create an array. 
- Returns — ndarray
    - An array object satisfying the specified requirements.
- Parameters
    - object — array_like 
        - An array, any object exposing the array interface, an object whose __array__ method returns an array, or any (nested) sequence. 
    - dtype — data-type, optional 
        - The desired data-type for the array. 
        - If not given, then the type will be determined as the minimum type required to hold the objects in the sequence. 
        - This argument can only be used to ‘upcast’ the array. 
            - For downcasting, use the .astype(t) method. 
    - copy — bool, optional 
        - If true (default), then the object is copied. 
        - Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (dtype, order, etc.). 
    - order — {‘K’, ‘A’, ‘C’, ‘F’}, optional 
        - Specify the memory layout of the array. 
        - If object is not an array, the newly created array will be in C order (row major) unless ‘F’ is specified, in which case it will be in Fortran order (column major). 
        - If object is an array the following holds. on. The default order is ‘K’. 
    - subok — bool, optional
        - If True, then sub-classes will be passed-through, 
        - otherwise the returned array will be forced to be a base-class array (default). 
    - ndmin — int, optional 
        - Specifies the minimum number of dimensions that the resulting array should have. Ones will be pre-pended to the shape as needed to meet this requirement. 
-->

### 1차원 배열
- 일반적으로 리스트를 배열로 변환하여 반환한다.
    - 리스트 —> 배열


```python
# 1차원 배열을 만든다.
arr1 = numpy.array([1, 2, 3])  
print(arr1)
print(type(arr1))
```

    [1 2 3]
    <class 'numpy.ndarray'>



```python
# 배열로 만들 전달인자(object)는 하나다.
numpy.array(1)
```




    array(1)




```python
# 배열로 만들 전달인자는 하나다.
# numpy.array(1, 'float')와 같다.
numpy.array(1, float)  
```




    array(1.)




```python
# 배열로 만들 전달인자는 하나다.
# numpy.array(1.0, int)와 같다.
numpy.array(1.0, 'int')  
```




    array(1)



**[주의]**


```python
# 배열로 만들 전달인자가 하나가 아니라 오류가 난다.
numpy.array(1, 2)  
```


    -----------------------------------------------------------------

    TypeError                       Traceback (most recent call last)

    <ipython-input-24-a80def8a1512> in <module>
          1 # 배열로 만들 전달인자가 하나가 아니라 오류가 난다.
    ----> 2 numpy.array(1, 2)
    

    TypeError: data type not understood



```python
# 배열로 만들 전달인자가 하나가 아니라 오류가 난다.
numpy.array([1], [2], [3])  
```


    -----------------------------------------------------------------

    ValueError                      Traceback (most recent call last)

    <ipython-input-25-14283c761afa> in <module>
          1 # 배열로 만들 전달인자가 하나가 아니라 오류가 난다.
    ----> 2 numpy.array([1], [2], [3])
    

    ValueError: only 2 non-keyword arguments accepted


### 다차원 배열
- 리스트를 배열로 변환하여 반환한다.
    - 리스트 —> 배열 


```python
# 2차원 배열을 만든다.
arr2 = numpy.array([[1, 2, 3],   
                    [4, 5, 6]])
arr2
```




    array([[1, 2, 3],
           [4, 5, 6]])



**[주의]**


```python
# 마찬가지로 배열로 만들 전달인자가 하나가 아니라 오류가 난다.
numpy.array([1, 2, 3],
            [4, 5, 6])  
```


    -----------------------------------------------------------------

    TypeError                       Traceback (most recent call last)

    <ipython-input-27-afde53520bba> in <module>
          1 # 마찬가지로 배열로 만들 전달인자가 하나가 아니라 오류가 난다.
    ----> 2 numpy.array([1, 2, 3],
          3             [4, 5, 6])  


    TypeError: data type not understood


## arange() 함수

[numpy.arange](https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html#numpy.arange)
- Return evenly spaced values within a given interval.
- numpy.**arange**(<i>[ start, ]stop, [step, ]dtype=None</i>)


```python
# 1차원 정수 배열을 만든다.
arr = numpy.arange(10)
print(arr)
print(type(arr))
```

    [0 1 2 3 4 5 6 7 8 9]
    <class 'numpy.ndarray'>



```python
# 1차원 실수 배열를 만든다.
numpy.arange(10, dtype='float64')  
```




    array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])




```python
# 1차원 실수 배열를 만든다.
numpy.arange(10, dtype=numpy.float64)  
```




    array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])




```python
# --- (주의)
numpy.arange(10, dtype=float64)  
```


    -----------------------------------------------------------------

    NameError                       Traceback (most recent call last)

    <ipython-input-31-c443bedfcc3f> in <module>
          1 # --- (주의)
    ----> 2 numpy.arange(10, dtype=float64)
    

    NameError: name 'float64' is not defined



```python
# 1차원 실수 배열을 만든다.
numpy.arange(10.0)
```




    array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])




```python
# 1차원 정수 배열을 만든다.
numpy.arange(3, 10)  
```




    array([3, 4, 5, 6, 7, 8, 9])




```python
# 1차원 실수 배열을 만든다.
numpy.arange(3, 10, 2, dtype=numpy.float64)
```




    array([3., 5., 7., 9.])




```python
# 1차원 정수 배열을 만든다.
numpy.arange(10, 3, -2)
```




    array([10,  8,  6,  4])




```python
# 1차원 정수 배열을 만든다.
numpy.arange(3, 10, -2)
```




    array([], dtype=int64)



## 내장함수

NumPy에 내장된 다양한 함수로도 배열을 만들 수 있다.

### zeros() 함수

[numpy.zeros](https://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros.html?highlight=zeros#numpy.zeros)
- Return a new array of given shape and type, filled with zeros.
- numpy.**zeros**(*shape, dtype=float, order='C'*)
    - ***dtype*** : *data-type, optional*
        - Default is **numpy.float64**.
    - ***order*** : *{‘C’, ‘F’}, optional, default: C*
        - Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.


```python
# 모든 값이 실수 0.0인 2차원(3 x 2) 배열을 만든다.
numpy.zeros(__TODO__) 
```

**실행 결과**
<pre>
array([[0., 0.],
       [0., 0.],
       [0., 0.]])
</pre>

### ones() 함수

[numpy.ones](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ones.html?highlight=ones#numpy.ones)
- Return a new array of given shape and type, filled with ones.
- numpy.**ones**(*shape, dtype=None, order='C'*)
    - ***dtype*** : *data-type, optional*
        - Default is **numpy.float64**.
    - ***order*** : *{‘C’, ‘F’}, optional, default: C*
        - Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.


```python
# 모든 값이 실수 1.0인 2차원(2 x 3) 배열을 만든다.
numpy.ones(__TODO__) 
```

**실행 결과**
<pre>
array([[1., 1., 1.],
       [1., 1., 1.]])
</pre>


```python
# 모든 값이 정수 1인 3차원(2 x 3 x 4) 배열을 만든다.
numpy.ones(__TODO__) 
```

**실행 결과**
<pre>
array([[[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]],

       [[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]]], dtype=int8)
</pre>

### full() 함수

[numpy.full](https://docs.scipy.org/doc/numpy/reference/generated/numpy.full.html?highlight=full#numpy.full)
- Return a new array of given shape and type, filled with fill_value.
- numpy.**full**(*shape, fill_value, dtype=None, order='C'*)
    - ***fill_value*** : *scalar*
        - Fill value.
    - ***dtype*** : *data-type, optional*
        - The desired data-type for the array The default, **None**, means *np.array(fill_value).dtype*.


```python
# 모든 값이 특정 상수 5인 2차원(1 x 2) 배열을 만든다.
numpy.full(__TODO__) 
```

**실행 결과**
<pre>
array([[5, 5]])
</pre>


```python
# 모든 값이 특정 상수 11.0인 2차원(3 x 2) 배열을 만든다.
numpy.full(__TODO__) 
```

**실행 결과**
<pre>
array([[11., 11.],
       [11., 11.],
       [11., 11.]])
</pre>


```python
# 모든 값이 infinity인 3차원(3 x 2 x 5) 배열을 만든다.
numpy.full(__TODO__) 
```

**실행 결과**
<pre>
array([[[inf, inf, inf, inf, inf],
        [inf, inf, inf, inf, inf]],

       [[inf, inf, inf, inf, inf],
        [inf, inf, inf, inf, inf]],

       [[inf, inf, inf, inf, inf],
        [inf, inf, inf, inf, inf]]])
</pre>

### eye() 함수

[numpy.eye](https://docs.scipy.org/doc/numpy/reference/generated/numpy.eye.html?highlight=eye#numpy.eye)
- Return a 2-D array with ones on the diagonal and zeros elsewhere.
- numpy.**eye**(*N, M=None, k=0, dtype=<class 'float'>, order='C'*)
    - ***N*** : *int*
        - Number of rows in the output.
    - ***M*** : *int, optional*
        - Number of columns in the output. If **None**, defaults to N.
    - ***k*** : *int, optional*
        - Index of the diagonal: **0** (the default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.
    - Returns: *ndarray of shape (N,M)*
        - An array where all elements are equal to zero, except for the *k*-th diagonal, whose values are equal to one.


```python
# 단위행렬 2차원(5 x 5) 배열을 만든다.
numpy.eye(__TODO__)
```

**실행 결과**
<pre>
array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])
</pre>


```python
# 단위행렬 2차원(5 x 2) 배열을 만든다.
numpy.eye(__TODO__)
```

**실행 결과**
<pre>
array([[1., 0.],
       [0., 1.],
       [0., 0.],
       [0., 0.],
       [0., 0.]])
</pre>


```python
# 단위행렬 2차원(5 x 5) 배열 주사선의 
# 상단 1 위의 사선을 1.0으로 채운 배열을 만든다.
numpy.eye(__TODO__)
```

**실행 결과**
<pre>
array([[0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.],
       [0., 0., 0., 0., 0.]])
</pre>


```python
# 단위행렬 2차원(5 x 5) 배열 주사선의 
# 하단 2 아래의 사선을 1.0으로 채운 배열을 만든다.
numpy.eye(__TODO__)
```

**실행 결과**
<pre>
array([[0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.]])
</pre>

### diag() 함수

[numpy.diag](https://docs.scipy.org/doc/numpy/reference/generated/numpy.diag.html?highlight=diag#numpy.diag)
- Extract a diagonal or construct a diagonal array.
- numpy.**diag**(*v, k=0*)
    - ***v*** : *array_like*
        - **v**가 2차원일 때와 1차원일 때 작동 방식이 다르다.
            - If ***v*** is a 2-D array, return a copy of its *k*-th diagonal. ***v***가 2차원 배열이면, 그 배열의 사선을 추출해서 1차원 배열을 만든다.
            - If ***v*** is a 1-D array, return a 2-D array with ***v*** on the *k*-th diagonal. ***v***가 1차원 배열이면, 그 배열의 값을 사선으로 가지는 2차원 배열을 반환한다.
    - ***k*** : *int, optional*
        - Diagonal in question. The default is **0**. Use *k > 0* for diagonals above the main diagonal, and *k < 0* for diagonals below the main diagonal.


```python
# 2차원(3 x 4) 배열
arr = numpy.array([[0, 1, 2, 3], 
                   [4, 5, 6, 7], 
                   [8, 9, 10, 11]])
arr
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11]])




```python
# 첫 번째 전달인자가 2차원(3 x 4) 배열이면, 
# 그 배열의 사선을 추출해서 1차원 배열을 만든다.
numpy.diag(__TODO__)   
```

**실행 결과**

<pre>
array([ 0,  5, 10])
</pre>


```python
# 2차원(3 x 4) 배열 주사선의 
# 상단 1 위의 사선을 추출해서 1차원 배열을 만든다.
numpy.diag(__TODO__)  
```

**실행 결과**

<pre>
array([ 1,  6, 11])
</pre>


```python
# 2차원(3 x 4) 배열 주사선의 
# 하단 2 아래의 사선을 추출해서 1차원 배열을 만든다.
numpy.diag(__TODO__)
```

**실행 결과**

<pre>
array([8])
</pre>


```python
# 첫 번째 전달인자가 1차원 배열이면, 
# 그 배열의 값을 사선으로 가지는 2차원 배열을 반환한다.
numpy.diag(__TODO__)
```

**실행 결과**

<pre>
array([[ 1,  0,  0],
       [ 0,  5,  0],
       [ 0,  0, 10]])
</pre>


```python
# 첫 번째 전달인자가 1차원 배열이고 k 값이 주어지면, 
# 그 배열의 값을 k만큼 이동한 사선으로 가지는 2차원 배열을 만든다.
numpy.diag(__TODO__)
```

**실행 결과**

<pre>
array([[ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 1,  0,  0,  0,  0],
       [ 0,  5,  0,  0,  0],
       [ 0,  0, 10,  0,  0]])
</pre>

### random.random() 함수

[numpy.random.Generator.random](https://docs.scipy.org/doc/numpy/reference/random/generated/numpy.random.Generator.random.html#numpy.random.Generator.random)
- **Uniform([0, 1))** 을 따르는 난수를 생성한다.
- Return random floats in the half-open interval [0.0, 1.0).
- Results are from the “continuous uniform” distribution over the stated interval.
- To sample $ Unif[a, b), b > a $ multiply the output of random by *(b-a)* and add *a*:

```
(b - a) * random() + a
```

- Generator.**random**(*size=None, dtype='d', out=None*)
    - ***size*** : *int or tuple of ints, optional*
        - Output shape. If the given shape is, e.g., **(m, n, k)**, then m * n * k samples are drawn. 
        - Default is **None**, in which case **a single value** is returned.
    - ***dtype*** : *{str, dtype}, optional*
        - Desired dtype of the result, either ‘d’ (or ‘float64’) or ‘f’ (or ‘float32’). All dtypes are determined by their name. 
        - The default value is ‘d’.
    - ***out*** : *ndarray, optional*
        - Alternative output array in which to place the result. If size is not **None**, it must have the same shape as the provided size and must match the type of the output values.


```python
# 임의의 실수(0 이상 1 이하)를 만든다.
numpy.random.random(__TODO__)
```

**실행 결과** (난수라 결괏값이 다를 수 있다.)

<pre>
0.158669862621163
</pre>


```python
# 임의의 실수(0 이상 1 이하)로 채워진 1차원(5,) 배열을 만든다.
numpy.random.random(__TODO__)
```

**실행 결과** (난수라 결괏값이 다를 수 있다.)

<pre>
array([0.51007175, 0.95131489, 0.44683025, 0.14221   , 0.62536888])
</pre>


```python
# 임의의 실수(0 이상 1 이하)로 채워진 2차원(1 x 5) 배열을 만든다.
numpy.random.random(__TODO__)
```

**실행 결과** (난수라 결괏값이 다를 수 있다.)

<pre>
array([[0.01113246, 0.59185488, 0.68591321, 0.47793059, 0.37867388]])
</pre>


```python
# 임의의 실수(0 이상 1 이하)로 채워진 2차원(2 x 5) 배열을 만든다.
numpy.random.random(__TODO__)
```

**실행 결과** (난수라 결괏값이 다를 수 있다.)

<pre>
array([[0.55054822, 0.64118906, 0.16147678, 0.00659165, 0.0820999 ],
       [0.4486739 , 0.94477232, 0.85518623, 0.64791878, 0.56812962]])
</pre>


```python
# 임의의 실수(0 이상 1 이하)로 채워진 3차원(1 x 2 x 5) 배열을 만든다.
numpy.random.random(__TODO__)
```

**실행 결과** (난수라 결괏값이 다를 수 있다.)

<pre>
array([[[0.41433655, 0.63445276, 0.49256226, 0.46185481, 0.99350968],
        [0.25883188, 0.48093216, 0.80540012, 0.58611193, 0.58452154]]])
</pre>


```python
# 임의의 실수(0 이상 1 이하)로 채워진 3차원(3 x 2 x 5) 배열을 만든다.
numpy.random.random(__TODO__)
```

**실행 결과** (난수라 결괏값이 다를 수 있다.)

<pre>
array([[[0.5905096 , 0.16951632, 0.16603211, 0.15509459, 0.20237966],
        [0.49626308, 0.52061899, 0.57882999, 0.30549207, 0.35387451]],

       [[0.57517844, 0.17575797, 0.15112638, 0.02778135, 0.20675852],
        [0.93780976, 0.77074595, 0.35435825, 0.05704222, 0.81728087]],

       [[0.42068377, 0.87854664, 0.16298413, 0.23334391, 0.80816247],
        [0.40971036, 0.82452463, 0.2821642 , 0.73260534, 0.78441163]]])
</pre>

### random.randint() 함수

[numpy.random.mtrand.RandomState.randint](https://docs.scipy.org/doc/numpy/reference/random/generated/numpy.random.mtrand.RandomState.randint.html#numpy.random.mtrand.RandomState.randint)
- Return random integers from ***low*** (inclusive) to ***high*** (exclusive).
- Return random integers from the “discrete uniform” distribution of the specified dtype in the “half-open” interval **[low, high)**. If ***high*** is **None** (the default), then results are from **[0, low)**.
- RandomState.**randint**(*low, high=None, size=None, dtype='l'*)
    - ***low*** : *int or array-like of ints*
        - Lowest (signed) integers to be drawn from the distribution (unless **high=None**, in which case this parameter is one above the highest such integer).
    - ***high*** : *int or array-like of ints, optional*
        - If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if **high=None**). If array-like, must contain integer values
    - ***size*** : *int or tuple of ints, optional*
        - Output shape. If the given shape is, e.g., **(m, n, k)**, then m * n * k samples are drawn. 
        - Default is **None**, in which case a single value is returned.
    - ***dtype*** : *dtype, optional*
        - Desired dtype of the result. All dtypes are determined by their name, i.e., ‘int64’, ‘int’, etc, so byteorder is not available and a specific precision may have different C types depending on the platform. 
        - The default value is ‘np.int’.


```python
# 0~4 사이의 임의의 정수로 채워진 1차원(10,) 배열을 만든다.
numpy.random.randint(__TODO__)
```

**실행 결과** (난수라 결괏값이 다를 수 있다.)

<pre>
array([2, 2, 4, 1, 4, 2, 4, 3, 4, 3])
</pre>


```python
# 0~4 사이의 임의의 정수로 채워진 2차원(2 x 5) 배열을 만든다.
numpy.random.randint(__TODO__)
```

**실행 결과** (난수라 결괏값이 다를 수 있다.)

<pre>
array([[2, 1, 1, 0, 3],
       [3, 3, 3, 2, 1]])
</pre>


```python
# 1 이상 (3 미만, 5 미만, 10 미만)의 
# 임의의 정수로 채워진 1차원(3) 배열을 만든다.
numpy.random.randint(__TODO__)
```

**실행 결과** (난수라 결괏값이 다를 수 있다.)

<pre>
array([1, 4, 9])
</pre>


```python
# (1 이상, 3 이상, 5 이상, 7 이상, 9 이상) 10 미만의 
# 임의의 정수로 채워진 1차원(3) 배열을 만든다.
numpy.random.randint(__TODO__)
```

**실행 결과** (난수라 결괏값이 다를 수 있다.)

<pre>
array([1, 4, 8, 9, 9])
</pre>


```python
# (1, 3, 5, 7 이상) x (첫 번째 행은 10 미만, 두 번째 행은 20 미만)의 
# 임의의 정수(uint)로 채워진 2차원(2 x 4) 배열을 만든다.
numpy.random.randint(__TODO__)
```

**실행 결과** (난수라 결괏값이 다를 수 있다.)

<pre>
array([[ 2,  3,  8,  9],
       [ 7, 18,  9, 10]], dtype=uint64)
</pre>

### Lab: 랜덤 벡터 생성과 정렬

- - -

- 길이 **10**인 랜덤 벡터(**1**차원 배열)을 생성하고 이를 정렬한다.

- 오름차순과 내림차순으로 한 번씩 정렬해 본다.

- - -


```python
# Your answer here
```

# 배열 자료형

[numpy.ndarray.**dtype**](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.dtype.html?highlight=dtype#numpy.ndarray.dtype)

- 배열의 자료형을 알려준다.


```python
arr1 = numpy.array([[1, 2, 3], [4, 5, 6]])
arr1.dtype, arr1.dtype.name
```




    (dtype('int64'), 'int64')




```python
arr2 = numpy.array([1.0])
arr2.dtype
```




    dtype('float64')




```python
arr3 = numpy.array([1, 2], dtype = numpy.float64)
arr3.dtype.name
```




    'float64'



## 형변환 메소드

[numpy.ndarray.astype](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html?highlight=astype#numpy.ndarray.astype)

- Copy of the array, cast to a specified type.
- ndarray.**astype**(*dtype, order='K', casting='unsafe', subok=True, copy=True*)
    - ***dtype*** : *str or dtype*
        - Typecode or data-type to which the array is cast.
    - Returns:
        - ***arr_t*** : *ndarray*
            - Unless ***copy*** is **False** and the other conditions for returning the input array are satisfied, ***arr_t*** is a new array of the same shape as the input array, with dtype, order given by dtype, order.


```python
arr = numpy.arange(1, 13)
arr
```




    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12])




```python
# 2차원(3 x 4) 배열로 변형한다.
arr.shape = __TODO__
arr
```

**실행 결과**

<pre>
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
</pre>


```python
# 8-bit unsigned integer로 형변환한다.
arr.astype(__TODO__)  
```

**실행 결과**

<pre>
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]], dtype=uint8)
</pre>


```python
# 정수를 문자열로 형변환한 numpy array를 생성한다.
arr.astype(__TODO__)
```

**실행 결과**

```
array([['1', '2', '3', '4'],
       ['5', '6', '7', '8'],
       ['9', '10', '11', '12']], dtype='<U21')
```


```python
# 문자열을 실수로 형변환한 numpy array를 생성한다.
numpy.array(['3.14', '-1.234', '0.9']).astype(__TODO__)
```

**실행 결과**

<pre>
array([ 3.14 , -1.234,  0.9  ])
</pre>

**참고**
- [NumPy 자료형](https://docs.scipy.org/doc/numpy/user/basics.types.html)

|Data Types|Description
:-|:-
**bool_**|Boolean (True or False) stored as a byte
**uint8**|Unsigned integer (0 to 255)
**uint16**|Unsigned integer (0 to 65535)
**uint32**|Unsigned integer (0 to 4294967295)
**uint64**|Unsigned integer (0 to 18446744073709551615)
**int_**|Default integer type (same as C long; normally either int64 or int32)
**intc**|Identical to C int (normally int32 or int64)
**intp**|Integer used for indexing (same as C ssize_t; normally either int32 or int64)
**int8**|Byte (-128 to 127)
**int16**|Integer (-32768 to 32767)
**int32**|Integer (-2147483648 to 2147483647)
**int64**|Integer (-9223372036854775808 to 9223372036854775807)
**float_**|Shorthand for float64
**float16**|Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
**float32**|Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
**float64**|Double precision float: sign bit, 11 bits exponent, 52 bits mantissa
**complex_**|Shorthand for complex128
**complex64**|Complex number, represented by two 32-bit floats (real and imaginary components)
**complex128**|Complex number, represented by two 64-bit floats (real and imaginary components)

<div align='right'><span style='font-size: smaller;'>[출처: https://www.tutorialspoint.com/numpy/numpy_data_types.htm]</span></div>

# 배열의 차원

## 차원(rank) : ndim

[numpy.ndarray.**ndim**](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.ndim.html?highlight=ndarray%20ndim#numpy.ndarray.ndim)
- Number of array dimensions.
- 배열이 몇 차원인지 알려준다.
- 배열의 차원을 **rank**라 부른다.


```python
# 1차원(3) 배열을 반환한다. rank = 1
arr1 = numpy.array([1, 2, 3])  
arr1.ndim
```




    1




```python
# 2차원(2 x 3)배열을 반환한다. rank = 2
arr2 = numpy.array([[1, 2, 3], 
                    [4, 5, 6]])  
arr2.ndim
```




    2




```python
# 3차원(3 x 2 x 4) 배열을 반환한다. rank = 3
arr3 = numpy.array([[[1, 2, 3, 4], 
                     [5, 6, 7, 8]],
                    
                    [[9, 10, 11, 12], 
                     [13, 14, 15, 16]],
                   
                    [[17, 18, 19, 20],
                     [21, 22, 23, 24]]])  
arr3.ndim
```




    3



## 차원 형태 : shape

[numpy.ndarray.**shape**](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.shape.html?highlight=shape#numpy.ndarray.shape)
- Tuple of array dimensions.
- 차원 형태를 튜플 자료형으로 알려준다.


```python
# 1차원(3) 배열을 반환한다.
arr1 = numpy.array([1, 2, 3])  
arr1.shape
```




    (3,)




```python
# 2차원(2 x 3)배열을 반환한다.
arr2 = numpy.array([[1, 2, 3], 
                    [4, 5, 6]])  
arr2.shape
```




    (2, 3)




```python
# 3차원(3 x 2 x 4) 배열을 반환한다.
arr3 = numpy.array([[[1, 2, 3, 4], 
                     [5, 6, 7, 8]],
                    
                    [[9, 10, 11, 12], 
                     [13, 14, 15, 16]],
                   
                    [[17, 18, 19, 20],
                     [21, 22, 23, 24]]])  
arr3.shape
```




    (3, 2, 4)



## 배열의 개수 : size

[numpy.ndarray.**size**](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.size.html?highlight=ndarray.size#numpy.ndarray.size)
- 배열이 가지고 있는 요소의 총 개수가 몇 개인지 알려준다.
    - 이는 차원 형태의 곱과 같다.
- Number of elements in the array.
    - Equal to **numpy.prod(arr.shape)**, i.e., the product of the array’s dimensions.


[참고]  
[numpy.**prod**(*a, axis=None, dtype=None, out=None, keepdims=None, initial=None, where=None)*](https://docs.scipy.org/doc/numpy/reference/generated/numpy.prod.html#numpy.prod)  
- Return the product of array elements over a given axis.
- **Parameters:**	
    - ***a*** : *array_like*
        - Input data.
    - ***axis*** : *None* or *int* or *tuple of ints*, optional
        - Axis or axes along which a product is performed. The default, **axis=None**, will calculate the product of all the elements in the input array. 
        - If axis is **negative** it counts from the last to the first axis.
        - If axis is a *tuple of ints*, a product is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.
    - ***dtype*** : *dtype*, optional
        - The type of the returned array, as well as of the accumulator in which the elements are multiplied. The *dtype* of *a* is used by default unless *a* has an integer *dtype* of less precision than the default platform integer. In that case, if *a* is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.
    - ***out*** : *ndarray*, optional
        - Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.
    - ***keepdims*** : *bool*, optional
        - If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.
        - If the default value is passed, then *keepdims* will not be passed through to the **prod** method of sub-classes of ndarray, however any non-default value will be. If the sub-class’ method does not implement keepdims any exceptions will be raised.
    - ***initial*** : *scalar*, optional
        - The starting value for this product. See reduce for details.
    - ***where*** : *array_like of bool*, optional
        - Elements to include in the product. See reduce for details.
- **Returns:**
    - ***product_along_axis*** : *ndarray*, see *dtype* parameter above.
        - An array shaped as *a* but with the specified axis removed. Returns a reference to out if specified.    


```python
# 1차원(3) 배열을 반환한다.
arr1 = numpy.array([1, 2, 3])
print(arr1)
print(arr1.shape)
print(arr1.size)
print(numpy.prod(arr1.shape))
```

    [1 2 3]
    (3,)
    3
    3



```python
# > arr1 = [1 2 3]
print(numpy.prod(arr1))
```

    6



```python
# 2차원(2 x 3)배열을 반환한다.
arr2 = numpy.array([[1, 2, 3], 
                    [4, 5, 6]])  
print(arr2)
print(arr2.shape)
print(arr2.size)
print(numpy.prod(arr2.shape))
```

    [[1 2 3]
     [4 5 6]]
    (2, 3)
    6
    6



```python
# > arr2 = [[1 2 3] [4 5 6]]
print(numpy.prod(arr2))
```

    720



```python
# > arr2 = [[1 2 3] [4 5 6]]
print(numpy.prod(arr2, 0))
```

    [ 4 10 18]



```python
# > arr2 = [[1 2 3] [4 5 6]]
print(numpy.prod(arr2, axis=1))
```

    [  6 120]



```python
# 3차원(3 x 2 x 4) 배열을 반환한다.
arr3 = numpy.array([[[1, 2, 3, 4], 
                     [4, 3, 2, 1]],
                    
                    [[2, 3, 4, 5], 
                     [1, 2, 3, 4]],
                   
                    [[4, 3, 2, 1],
                     [0, 1, 0, 1]]])  
print(arr3)
print(arr3.shape)
print(arr3.size)
print(numpy.prod(arr3.shape))
```

    [[[1 2 3 4]
      [4 3 2 1]]
    
     [[2 3 4 5]
      [1 2 3 4]]
    
     [[4 3 2 1]
      [0 1 0 1]]]
    (3, 2, 4)
    24
    24



```python
# > arr3 = [[[1 2 3 4]
#            [4 3 2 1]]
#
#           [[2 3 4 5]
#            [1 2 3 4]]
#
#           [[4 3 2 1]
#            [0 1 0 1]]]
print(numpy.prod(arr3))
```

    0



```python
# > arr3 = [[[1 2 3 4]
#            [4 3 2 1]]
#
#           [[2 3 4 5]
#            [1 2 3 4]]
#
#           [[4 3 2 1]
#            [0 1 0 1]]]
print(numpy.prod(arr3, 0))
```

    [[ 8 18 24 20]
     [ 0  6  0  4]]



```python
# > arr3 = [[[1 2 3 4]
#            [4 3 2 1]]
#
#           [[2 3 4 5]
#            [1 2 3 4]]
#
#           [[4 3 2 1]
#            [0 1 0 1]]]
print(numpy.prod(arr3, axis=(0, 1)))
```

    [  0 108   0  80]



```python
# > arr3 = [[[1 2 3 4]
#            [4 3 2 1]]
#
#           [[2 3 4 5]
#            [1 2 3 4]]
#
#           [[4 3 2 1]
#            [0 1 0 1]]]
print(numpy.prod(arr3, (0, 1, 2))) # numpy.prod(arr3)과 같다.
```

    0


## 차원 변경 : reshape()

[**numpy.ndarray.reshape**](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.reshape.html#numpy.ndarray.reshape)
- **reshape()** 함수로 차원을 변경할 수 있다.
- Gives a new shape to an array without changing its data.
- ndarray.**reshape**(*shape, order='C'*)
    - Refer to **numpy.reshape** for full documentation.


```python
# 1차원 배열을 생성한다.
arr = numpy.arange(15)
arr
```




    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])




```python
# 1차원 배열로 2차원 배열(3 x 5)을 생성한다.
arr.reshape(__TODO__)
```

**실행 결과**

<pre>
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
</pre>


```python
# 1차원 배열 arr를 2차원 배열(5 x 3)로 바꾼다.
arr = __TODO__
arr
```

**실행 결과**

<pre>
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
       [12, 13, 14]])
</pre>


```python
# 1차원 배열을 3차원 배열(3 x 2 x 4)로 바꾼다.
arr = numpy.arange(1, 25).__TODO__
arr
```

**실행 결과**

<pre>
array([[[ 1,  2,  3,  4],
        [ 5,  6,  7,  8]],

       [[ 9, 10, 11, 12],
        [13, 14, 15, 16]],

       [[17, 18, 19, 20],
        [21, 22, 23, 24]]])
</pre>

[**numpy.reshape**](https://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html?highlight=reshape#numpy.reshape)
- Gives a new shape to an array without changing its data.
- numpy.**reshape**(*a, newshape, order='C'*)
    - ***a*** : *array_like*
        - Array to be reshaped.
    - ***newshape*** : *int or tuple of ints*
        - The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.


```python
# 1차원 배열을 전달받아 2차원 배열(2 x 15)로 바꾼다.
arr = numpy.reshape(numpy.arange(1, 31), __TODO__)
arr
```

**실행 결과**

<pre>
array([[ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15],
       [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]])
</pre>


```python
# 2차원 배열(2 x 15) arr를 3차원 배열(3 x 2 x 5)로 바꾼 배열을 반환한다.
numpy.reshape(__TODO__)
```

**실행 결과**

<pre>
array([[[ 1,  2,  3,  4,  5],
        [ 6,  7,  8,  9, 10]],

       [[11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20]],

       [[21, 22, 23, 24, 25],
        [26, 27, 28, 29, 30]]])
</pre>


```python
# 2차원 배열(2 x 15) arr를 다른 형태의 2차원 배열(10 x 3)로 바꾼 배열을 반환한다.
numpy.reshape(__TODO__)
```

**실행 결과**

<pre>
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
       [10, 11, 12],
       [13, 14, 15],
       [16, 17, 18],
       [19, 20, 21],
       [22, 23, 24],
       [25, 26, 27],
       [28, 29, 30]])
</pre>


```python
# 2차원 배열(2 x 15) arr를 1차원 배열로 바꾼다.
numpy.reshape(__TODO__)
```

**실행 결과**

<pre>
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
       18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])
</pre>

## Lab: 벡터를 행렬로 변환하기

- - -

길이 **9**의 벡터(**1**차원 배열)를 생성하고 이를 **3** x **3** 크기의 행렬로 변환한다.

- - -

**힌트**
- NumPy의 **arange()** 함수를 이용해 **0**부터 **8**까지의 정수를 담은 1차원 배열을 생성한다.
- 이를 **reshape()** 함수로 2차원 배열로 변환하면 된다.


```python
# Your answer here
```

## Lab: 대각행렬(diagonal matrix)

- - -

길이 **9**의 벡터(**1**차원 배열)를 생성한 후 생성한 행렬을 대각행렬로 변환한다.

1. 우선 행렬의 주대각 원소(대각선상에 있는 원소)만 **1**차원 배열로 출력한다.
1. **3** x **3** 대각행렬(정사각행렬의 주대각 성분 이외의 모든 성분이 **0**인 행렬)로 변환한다.

- - -


```python
# Your answer here
```

- - -

# THE END