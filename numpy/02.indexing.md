- - -

# 넘파이 입문 : 인덱싱

### NumPy Primer: Indexing

* * *

**박 진 수** 교수  
Intelligent Data Semantics Lab  
Seoul National University


- - -

<h3>Table of Contents<span class="tocSkip"></span></h3>
<div class="toc"><ul class="toc-item"><li><span><a href="#단일-인덱싱" data-toc-modified-id="단일-인덱싱-1">단일 인덱싱</a></span><ul class="toc-item"><li><span><a href="#1차원-배열의-단일-인덱싱" data-toc-modified-id="1차원-배열의-단일-인덱싱-1.1">1차원 배열의 단일 인덱싱</a></span></li><li><span><a href="#다차원-배열의-단일-인덱싱" data-toc-modified-id="다차원-배열의-단일-인덱싱-1.2">다차원 배열의 단일 인덱싱</a></span><ul class="toc-item"><li><span><a href="#2차원" data-toc-modified-id="2차원-1.2.1">2차원</a></span></li><li><span><a href="#3차원" data-toc-modified-id="3차원-1.2.2">3차원</a></span></li></ul></li><li><span><a href="#다차원-배열의-단일-부분-인덱싱" data-toc-modified-id="다차원-배열의-단일-부분-인덱싱-1.3">다차원 배열의 단일 부분 인덱싱</a></span><ul class="toc-item"><li><span><a href="#2차원" data-toc-modified-id="2차원-1.3.1">2차원</a></span></li><li><span><a href="#3차원" data-toc-modified-id="3차원-1.3.2">3차원</a></span></li></ul></li></ul></li><li><span><a href="#배열-인덱싱" data-toc-modified-id="배열-인덱싱-2">배열 인덱싱</a></span><ul class="toc-item"><li><span><a href="#배열-인덱싱이란?" data-toc-modified-id="배열-인덱싱이란?-2.1">배열 인덱싱이란?</a></span><ul class="toc-item"><li><span><a href="#단일-인덱싱의-객체-참조" data-toc-modified-id="단일-인덱싱의-객체-참조-2.1.1">단일 인덱싱의 객체 참조</a></span></li><li><span><a href="#배열-인덱싱의-객체-참조" data-toc-modified-id="배열-인덱싱의-객체-참조-2.1.2">배열 인덱싱의 객체 참조</a></span></li></ul></li><li><span><a href="#1차원-배열의-배열-인덱싱" data-toc-modified-id="1차원-배열의-배열-인덱싱-2.2">1차원 배열의 배열 인덱싱</a></span></li><li><span><a href="#다차원-배열의-배열-인덱싱" data-toc-modified-id="다차원-배열의-배열-인덱싱-2.3">다차원 배열의 배열 인덱싱</a></span><ul class="toc-item"><li><span><a href="#2차원-배열의-1차원-배열-인덱싱" data-toc-modified-id="2차원-배열의-1차원-배열-인덱싱-2.3.1">2차원 배열의 1차원 배열 인덱싱</a></span></li><li><span><a href="#3차원-배열의-1차원-배열-인덱싱" data-toc-modified-id="3차원-배열의-1차원-배열-인덱싱-2.3.2">3차원 배열의 1차원 배열 인덱싱</a></span></li></ul></li><li><span><a href="#부분-배열-인덱싱" data-toc-modified-id="부분-배열-인덱싱-2.4">부분 배열 인덱싱</a></span><ul class="toc-item"><li><span><a href="#2차원-배열의-부분-배열-인덱싱" data-toc-modified-id="2차원-배열의-부분-배열-인덱싱-2.4.1">2차원 배열의 부분 배열 인덱싱</a></span></li><li><span><a href="#3차원-배열의-부분-배열-인덱싱" data-toc-modified-id="3차원-배열의-부분-배열-인덱싱-2.4.2">3차원 배열의 부분 배열 인덱싱</a></span></li></ul></li></ul></li><li><span><a href="#다차원-배열-인덱싱" data-toc-modified-id="다차원-배열-인덱싱-3">다차원 배열 인덱싱</a></span><ul class="toc-item"><li><span><a href="#다차원-배열-인덱싱이란?" data-toc-modified-id="다차원-배열-인덱싱이란?-3.1">다차원 배열 인덱싱이란?</a></span></li><li><span><a href="#1차원-배열의-다차원-배열-인덱싱" data-toc-modified-id="1차원-배열의-다차원-배열-인덱싱-3.2">1차원 배열의 다차원 배열 인덱싱</a></span><ul class="toc-item"><li><span><a href="#1차원-배열-인덱싱" data-toc-modified-id="1차원-배열-인덱싱-3.2.1">1차원 배열 인덱싱</a></span></li><li><span><a href="#고차원-배열-인덱싱" data-toc-modified-id="고차원-배열-인덱싱-3.2.2">고차원 배열 인덱싱</a></span><ul class="toc-item"><li><span><a href="#2차원-배열-인덱싱" data-toc-modified-id="2차원-배열-인덱싱-3.2.2.1">2차원 배열 인덱싱</a></span></li><li><span><a href="#3차원-배열-인덱싱" data-toc-modified-id="3차원-배열-인덱싱-3.2.2.2">3차원 배열 인덱싱</a></span></li></ul></li></ul></li><li><span><a href="#2차원-배열의-다차원-배열-인덱싱" data-toc-modified-id="2차원-배열의-다차원-배열-인덱싱-3.3">2차원 배열의 다차원 배열 인덱싱</a></span><ul class="toc-item"><li><span><a href="#1차원-배열-인덱싱" data-toc-modified-id="1차원-배열-인덱싱-3.3.1">1차원 배열 인덱싱</a></span></li><li><span><a href="#2차원-배열-인덱싱" data-toc-modified-id="2차원-배열-인덱싱-3.3.2">2차원 배열 인덱싱</a></span></li><li><span><a href="#고차원(3차원)-배열-인덱싱" data-toc-modified-id="고차원(3차원)-배열-인덱싱-3.3.3">고차원(3차원) 배열 인덱싱</a></span></li><li><span><a href="#Lab:-2차원-배열의-3차원-배열-인덱싱" data-toc-modified-id="Lab:-2차원-배열의-3차원-배열-인덱싱-3.3.4">Lab: 2차원 배열의 3차원 배열 인덱싱</a></span><ul class="toc-item"><li><span><a href="#문제-1" data-toc-modified-id="문제-1-3.3.4.1">문제 1</a></span></li><li><span><a href="#문제-2" data-toc-modified-id="문제-2-3.3.4.2">문제 2</a></span></li><li><span><a href="#문제-3" data-toc-modified-id="문제-3-3.3.4.3">문제 3</a></span></li></ul></li></ul></li></ul></li><li><span><a href="#분할-연산" data-toc-modified-id="분할-연산-4">분할 연산</a></span><ul class="toc-item"><li><span><a href="#분할-연산(slicing)이란?-:-[-:-:-]" data-toc-modified-id="분할-연산(slicing)이란?-:-[-:-:-]-4.1">분할 연산(slicing)이란? : <strong>[ : : ]</strong></a></span></li><li><span><a href="#1차원-배열-분할" data-toc-modified-id="1차원-배열-분할-4.2">1차원 배열 분할</a></span></li><li><span><a href="#다차원-배열-분할" data-toc-modified-id="다차원-배열-분할-4.3">다차원 배열 분할</a></span><ul class="toc-item"><li><span><a href="#2차원-배열의-분할-연산" data-toc-modified-id="2차원-배열의-분할-연산-4.3.1">2차원 배열의 분할 연산</a></span></li><li><span><a href="#3차원-배열의-분할-연산" data-toc-modified-id="3차원-배열의-분할-연산-4.3.2">3차원 배열의 분할 연산</a></span></li><li><span><a href="#분할-연산과-정수-인덱스를-함께-사용할-때와-분할-연산만-할-때의-차이" data-toc-modified-id="분할-연산과-정수-인덱스를-함께-사용할-때와-분할-연산만-할-때의-차이-4.3.3">분할 연산과 정수 인덱스를 함께 사용할 때와 분할 연산만 할 때의 차이</a></span></li></ul></li><li><span><a href="#다차원-배열의-부분-분할" data-toc-modified-id="다차원-배열의-부분-분할-4.4">다차원 배열의 부분 분할</a></span><ul class="toc-item"><li><span><a href="#2차원-배열의-부분-분할" data-toc-modified-id="2차원-배열의-부분-분할-4.4.1">2차원 배열의 부분 분할</a></span></li><li><span><a href="#3차원-배열의-부분-분할" data-toc-modified-id="3차원-배열의-부분-분할-4.4.2">3차원 배열의 부분 분할</a></span></li></ul></li></ul></li><li><span><a href="#불린-배열-인덱싱" data-toc-modified-id="불린-배열-인덱싱-5">불린 배열 인덱싱</a></span><ul class="toc-item"><li><span><a href="#불린-배열-인덱싱이란?" data-toc-modified-id="불린-배열-인덱싱이란?-5.1">불린 배열 인덱싱이란?</a></span></li><li><span><a href="#다차원-배열에서-부분-불린-인덱싱" data-toc-modified-id="다차원-배열에서-부분-불린-인덱싱-5.2">다차원 배열에서 부분 불린 인덱싱</a></span></li></ul></li></ul></div>


```python
import numpy  # as np

# 버전을 확인한다.
print('NumPy version...:', numpy.__version__)  
```

# 단일 인덱싱

**단일 인덱싱**(single element indexing)이란?
- 일반적으로 알려진 인덱싱과 유사하다.
- 반환한 배열은 원본의 복사본이 아니라 원본 배열과 동일한 객체를 참조한다.
    + <배열 인덱싱> 참조

## 1차원 배열의 단일 인덱싱

**특징**
+ 리스트와 같은 방식으로 특정 객체를 추출한다.


```python
# 1차원(5,) 배열을 만든다. rank = 1
arr1 = numpy.arange(1, 6)
arr1
```




    array([1, 2, 3, 4, 5])




```python
# 1차원 배열 arr1의 첫 번째 값을 추출한다.
__TODO__
```

**실행 결과**

<pre>1
</pre>


```python
# 1차원 배열 arr1의 끝에서 두 번째 값을 추출한다.
__TODO__
```

**실행 결과**

<pre>4
</pre>

## 다차원 배열의 단일 인덱싱

**특징**
- 다차원 배열에 대한 단일 인덱싱도 지원한다.
- NumPy 배열은 파이썬 시퀀스 자료형과는 달리, 각 차원을 대괄호로 구분하여 인덱싱하지 않아도 된다.

### 2차원


```python
# 2차원(2, 5) 배열을 만든다.
arr2 = numpy.arange(1, 11).reshape(2, 5)
arr2
```




    array([[ 1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10]])




```python
# 2차원 배열 arr2의 마지막 행 마지막 열의 값을 추출한다.
__TODO__
```

**실행 결과**

<pre>10
</pre>

### 3차원


```python
# 3차원(2, 3, 4) 배열을 만든다.
arr3 = numpy.arange(1, 25).reshape(2, 3, 4)
arr3
```




    array([[[ 1,  2,  3,  4],
            [ 5,  6,  7,  8],
            [ 9, 10, 11, 12]],
    
           [[13, 14, 15, 16],
            [17, 18, 19, 20],
            [21, 22, 23, 24]]])




```python
# 3차원 배열 arr3 첫 번째 묶음의 두 번째 행 마지막 열을 추출한다.
__TODO__
```

**실행 결과**

<pre>8
</pre>

## 다차원 배열의 단일 부분 인덱싱

**특징**
- 차원(rank)보다 적은 수의 인덱스를 사용하면 낮은 차원의 배열을 추출한다.

### 2차원


```python
# 2차원(2, 5) 배열을 만든다.
arr2 = numpy.arange(1, 11).reshape(2, 5)
arr2
```




    array([[ 1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10]])




```python
# 2차원 배열 arr2의 두 번째 행을 추출한다. 
# 차원보다 적은 수의 인덱스를 사용하기 때문에 낮은 차원의 배열을 추출하게 된다. 
__TODO__
```




    array([ 6,  7,  8,  9, 10])



**실행 결과**

<pre>
array([ 6,  7,  8,  9, 10])
</pre>

### 3차원


```python
# 3차원(2, 3, 4) 배열을 만든다.
arr3 = numpy.arange(1, 25).reshape(2, 3, 4)
arr3
```




    array([[[ 1,  2,  3,  4],
            [ 5,  6,  7,  8],
            [ 9, 10, 11, 12]],
    
           [[13, 14, 15, 16],
            [17, 18, 19, 20],
            [21, 22, 23, 24]]])




```python
# 3차원 배열 arr3 마지막 묶음의 마지막 행 전체를 추출한다. 
__TODO__
```

**실행 결과**

<pre>
array([21, 22, 23, 24])
</pre>


```python
# 3차원 배열 arr3의 첫 번째 묶음을 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
</pre>

# 배열 인덱싱

## 배열 인덱싱이란?

**배열 인덱싱**(index arrays)이란?
- NumPy 배열을 인덱싱할 때 배열이나 리스트 등을 인덱스로 사용할 수 있다.
- 배열 인덱싱을 하면 
    + 배열의 개별 값들을 모두 순회하지 않아도 되기 때문에 **인덱싱 속도를 향상**시킬 수 있다.
    + 배열의 차원 수를 늘리거나 줄일 수가 있어 표현식이나 함수의 전달인자에 **필요한 차원으로 바꿀 수 있다**.
- 배열 인덱싱을 하면 원본 배열과 동일한 객체를 참조하는 것이 아니라 원본과 **별도의 복사본**을 반환한다.    
    + **[참고]** 단일 인덱싱을 하면 원본 배열과 **동일한 객체를 참조**하는 배열을 반환한다.

### 단일 인덱싱의 객체 참조


```python
arr1 = numpy.arange(1, 11).reshape(2, 5)
arr2 = arr1[0]  # 단일 인덱싱으로 첫 번째 행을 추출한다.
print('arr1:', arr1, sep='\n')
print('arr2:', arr2, sep='\n')
```

    arr1:
    [[ 1  2  3  4  5]
     [ 6  7  8  9 10]]
    arr2:
    [1 2 3 4 5]



```python
# arr1의 첫 번째 열, 첫 번째 행의 값을 1에서 -1로 바꾼다.
arr1[0, 0] = -1  
print('arr1:', arr1, sep='\n')
print('arr2:', arr2, sep='\n')  # arr2의 값도 함께 바뀌었다.
```

    arr1:
    [[-1  2  3  4  5]
     [ 6  7  8  9 10]]
    arr2:
    [-1  2  3  4  5]


### 배열 인덱싱의 객체 참조


```python
arr1 = numpy.arange(1, 11).reshape(2, 5)
arr2 = arr1[[0]]  # 배열 인덱싱으로 첫 번째 열을 추출한다.
print('arr1:', arr1, sep='\n')
print('arr2:', arr2, sep='\n')
```

    arr1:
    [[ 1  2  3  4  5]
     [ 6  7  8  9 10]]
    arr2:
    [[1 2 3 4 5]]



```python
# arr1의 첫 번째 열, 첫 번째 행의 값을 1에서 -1로 바꾼다.
arr1[0, 0] = -1  
print('arr1:', arr1, sep='\n')
print('arr2:', arr2, sep='\n')  # arr2의 값은 그대로다.
```

    arr1:
    [[-1  2  3  4  5]
     [ 6  7  8  9 10]]
    arr2:
    [[1 2 3 4 5]]


## 1차원 배열의 배열 인덱싱

**특징**
- 배열 인덱싱의 각 인덱스를 해당 인덱스의 배열 값으로 대체한 배열을 반환한다.


```python
# 1차원(15,) 배열을 만든다. rank = 1
arr = numpy.arange(1, 16)
arr
```




    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15])




```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
# 인덱스로 사용하는 배열의 각 인덱스 위치에 해당 인덱스의 배열 값으로 대체한 배열을 반환한다.
arr[__TODO__]  
```

**실행 결과**

<pre>
array([15,  1, 15, 15,  2])
</pre>


```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
# 인덱스로 사용하는 배열의 각 인덱스 위치에 해당 인덱스의 배열 값으로 대체한 배열을 반환한다.
arr[__TODO__]  
```

**실행 결과**

<pre>
array([11, 11, 11, 11, 11])
</pre>

## 다차원 배열의 배열 인덱싱

- 모든 배열 인덱스의 차원 형태(shape)가 같고, 인덱싱 할 배열의 각 차원에 상응하는 배열 인덱스가 있다면, 반환하는 배열은 배열 인덱스와 **같은 차원 형태(shape)를 가진 배열**이다.
- 이때 반환하는 배열의 값들은 배열 인덱스의 각 위치에 대한 인덱스 세트에 해당한다.

### 2차원 배열의 1차원 배열 인덱싱


```python
# 2차원(5, 3) 배열이다. rank = 2
arr = numpy.arange(1, 16).reshape(5, 3)
arr
```




    array([[ 1,  2,  3],
           [ 4,  5,  6],
           [ 7,  8,  9],
           [10, 11, 12],
           [13, 14, 15]])




```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
arr[__TODO__]  
```

**실행 결과**

<pre>
array([ 1, 15])
</pre>


```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
arr[__TODO__]  
```

**실행 결과**

<pre>
array([ 2, 14,  5])
</pre>


```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
arr[__TODO__]  
```

**실행 결과**

<pre>
array([4, 6, 5])
</pre>

### 3차원 배열의 1차원 배열 인덱싱


```python
# 3차원(2, 3, 4) 배열이다. rank = 3
arr = numpy.arange(1, 25).reshape(2, 3, 4)
arr
```




    array([[[ 1,  2,  3,  4],
            [ 5,  6,  7,  8],
            [ 9, 10, 11, 12]],
    
           [[13, 14, 15, 16],
            [17, 18, 19, 20],
            [21, 22, 23, 24]]])




```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
arr[__TODO__]  
```

**실행 결과**

<pre>
array([ 1, 24])
</pre>


```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
arr[__TODO__]  
```

**실행 결과**

<pre>
array([ 7, 18, 17])
</pre>


```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
arr[__TODO__]  
```

**실행 결과**

<pre>
array([ 8, 20, 20])
</pre>


```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
arr[__TODO__]  
```

**실행 결과**

<pre>
array([5, 6, 7])
</pre>

## 부분 배열 인덱싱

### 2차원 배열의 부분 배열 인덱싱


```python
# 2차원(5, 3) 배열이다. rank = 2
arr = numpy.arange(1, 16).reshape(5, 3)
arr
```




    array([[ 1,  2,  3],
           [ 4,  5,  6],
           [ 7,  8,  9],
           [10, 11, 12],
           [13, 14, 15]])




```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
arr[__TODO__]  
```

**실행 결과**

<pre>
array([[ 1,  2,  3],
       [13, 14, 15],
       [ 4,  5,  6]])
</pre>


```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
arr[__TODO__]  
```

**실행 결과**

<pre>
array([[ 1,  2,  3],
       [13, 14, 15]])
</pre>

### 3차원 배열의 부분 배열 인덱싱


```python
# 3차원(2, 3, 4) 배열이다. rank = 3
arr = numpy.arange(1, 25).reshape(2, 3, 4)
arr
```




    array([[[ 1,  2,  3,  4],
            [ 5,  6,  7,  8],
            [ 9, 10, 11, 12]],
    
           [[13, 14, 15, 16],
            [17, 18, 19, 20],
            [21, 22, 23, 24]]])




```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
arr[__TODO__]  
```

**실행 결과**

<pre>
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [21, 22, 23, 24]])
</pre>


```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
arr[__TODO__]  
```

**실행 결과**

<pre>
array([[13, 14, 15, 16],
       [17, 18, 19, 20]])
</pre>


```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
arr[__TODO__]  
```

**실행 결과**

<pre>
array([[5, 6, 7, 8]])
</pre>


```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
arr[__TODO__]  
```

**실행 결과**

<pre>
array([[[ 1,  2,  3,  4],
        [ 5,  6,  7,  8],
        [ 9, 10, 11, 12]],

       [[13, 14, 15, 16],
        [17, 18, 19, 20],
        [21, 22, 23, 24]],

       [[ 1,  2,  3,  4],
        [ 5,  6,  7,  8],
        [ 9, 10, 11, 12]]])
</pre>


```python
# arr의 값을 아래 실행 결과처럼 추출하려면?
arr[__TODO__]  
```

**실행 결과**

<pre>
rray([[[13, 14, 15, 16],
        [17, 18, 19, 20],
        [21, 22, 23, 24]]])
</pre>

# 다차원 배열 인덱싱

## 다차원 배열 인덱싱이란?

인덱싱하려는 배열의 차원과 상관없이 **배열 인덱싱의 차원과 같은 차원의 배열을 반환**한다.

## 1차원 배열의 다차원 배열 인덱싱


```python
# 1차원(24,) 배열을 만든다. rank = 1
arr1 = numpy.arange(1, 25)
arr1
```




    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
           18, 19, 20, 21, 22, 23, 24])



### 1차원 배열 인덱싱

- 1차원 배열을 반환한다.
- 앞서 <배열 인덱싱>에서 다루었다.
    + <1차원 배열의 배열 인덱싱> 참조    


```python
# arr1의 값을 아래 실행 결과처럼 추출하려면?
arr1[__TODO__]  
```

**실행 결과**

<pre>
array([ 1,  3,  5,  7,  9, 24,  1])
</pre>

### 고차원 배열 인덱싱

1차원 배열에 **고차원 배열 인덱싱**을 하려면 **numpy 배열을 배열 인덱싱을 사용**해야 한다.

#### 2차원 배열 인덱싱

- 2차원 배열을 반환한다.


```python
# --- arr1의 값을 아래 실행 결과처럼 추출하려면?
# 2차원 배열 인덱싱을 하면 1차원 배열을 2차원 배열(1, 7)로 추출한다.
# [주의] 다차원 배열 인덱싱은 NumPy 배열을 사용해야 한다.
arr1[__TODO__]  
```

**실행 결과**

<pre>
array([[ 1,  3,  5,  7,  9, 24,  1]])
</pre>


```python
# --- arr1의 값을 아래 실행 결과처럼 추출하려면?
# 2차원 배열 인덱싱을 하면 1차원 배열을 2차원 배열(2, 5)로 추출한다.
# [주의] 다차원 배열 인덱싱은 NumPy 배열을 사용해야 한다.
arr1[__TODO__]  
```

**실행 결과**

<pre>
array([[ 1,  3,  5,  7,  9],
       [ 2,  4,  6,  8, 10]])
</pre>

#### 3차원 배열 인덱싱

- 3차원 배열을 반환한다.


```python
# --- arr1의 값을 아래 실행 결과처럼 추출하려면?
# 3차원 배열 인덱싱을 하면 1차원 배열을 3차원 배열(1, 1, 5)로 추출한다.
# [주의] 다차원 배열 인덱싱은 NumPy 배열을 사용해야 한다.
arr1[__TODO__]  
```

**실행 결과**

<pre>
array([[[ 1,  3,  5,  7,  9, 24,  1]]])
</pre>


```python
# --- arr1의 값을 아래 실행 결과처럼 추출하려면?
# 3차원 배열 인덱싱을 하면 1차원 배열을 3차원 배열(1, 2, 5)로 추출한다.
# [주의] 다차원 배열 인덱싱은 NumPy 배열을 사용해야 한다.
arr1[__TODO__]  
```

**실행 결과**

<pre>
array([[[ 1,  3,  5,  7,  9],
        [ 2,  4,  6,  8, 10]]])
</pre>


```python
# --- arr1의 값을 아래 실행 결과처럼 추출하려면?
# 3차원 배열 인덱싱을 하면 1차원 배열을 3차원 배열(2, 3, 4)로 추출한다.
# [주의] 다차원 배열 인덱싱은 NumPy 배열을 사용해야 한다.
arr1[__TODO__]  
```

**실행 결과**

<pre>
array([[[ 1,  2,  3,  4],
        [24,  1,  2,  3],
        [23, 24,  1,  2]],

       [[24,  1, 24,  1],
        [ 1,  1,  1,  1],
        [ 2,  2,  2,  2]]])
</pre>

## 2차원 배열의 다차원 배열 인덱싱


```python
# 2차원(4, 6) 배열을 만든다. rank = 2
arr2 = numpy.arange(1, 25).reshape(4, 6)
arr2
```




    array([[ 1,  2,  3,  4,  5,  6],
           [ 7,  8,  9, 10, 11, 12],
           [13, 14, 15, 16, 17, 18],
           [19, 20, 21, 22, 23, 24]])



### 1차원 배열 인덱싱

- 1차원 배열을 반환한다.
- 앞서 <배열 인덱싱>에서 다루었다.
    + <다차원 배열의 배열 인덱싱>의 <2차원 배열의 1차원 배열 인덱싱> 참조


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 행의 마지막 열과 두 번째 행의 첫 번째 열을 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([6, 7])
</pre>


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 행의 마지막 열과 두 번째 행의 마지막 열을 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([ 6, 12])
</pre>

### 2차원 배열 인덱싱

- 2차원 배열을 반환한다.


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 행의 마지막 열과 두 번째 행의 첫 번째 열을 
# 2차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[6, 7]])
</pre>


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번쨰 행의 마지막 열, 두 번쨰 행의 마지막 열, 
# 세 번째 행의 마지막 열을 2차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[ 6, 12, 18]])
</pre>


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 행에 첫 번째 행의 마지막 열, 두 번째 행의 첫 번쨰 열을
# 두 번째 행에 세 번째 행의 첫 번째 열, 네 번째 행의 마지막 열을
# 2차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[ 6,  7],
       [13, 24]])
</pre>


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 행에 첫 번째 행의 마지막 열, 두 번째 행의 첫 번째 열, 세 번째 행의 두 번쨰 열을
# 두 번째 행에 네 번째 행의 마지막 열, 세 번째 행의 첫 번째 열, 두 번째 행의 두 번쨰 열을
# 2차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[ 6,  7, 14],
       [24, 13,  8]])
</pre>


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 행에 첫 번째 행의 마지막 열, 두 번째 행의 마지막 열을
# 두 번째 행에 세 번째 행의 첫 번째 열, 네 번째 행의 첫 번째 열을
# 2차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[ 6, 12],
       [13, 19]])
</pre>


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 행에 첫 번째 행의 마지막 열, 두 번째 행의 마지막 열을
# 두 번째 행에 세 번째 행의 마지막 열, 네 번째 행의 마지막 열을
# 2차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[ 6, 12],
       [18, 24]])
</pre>

### 고차원(3차원) 배열 인덱싱

- 3차원 배열을 반환한다.


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 묶음의 첫 번째 행에
# 첫 번째 행의 마지막 열, 두 번째 행의 첫 번째 열, 두 번째 행의 마지막 열, 
# 네 번째 행의 첫 번째 열을 3차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[[ 6,  7, 12, 19]]])
</pre>


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 묶음의 첫 번째 행에
# 첫 번째 행의 마지막 열, 두 번째 행의 마지막 열, 두 번째 행의 마지막 열, 
# 네 번째 행의 마지막 열을 3차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[[ 6, 12, 18, 24]]])
</pre>


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 묶음의 첫 번째 행에 
# 첫 번째 행의 첫 번쨰 열, 두 번째 행의 두 번째 열, 세 번째 행의 세 번째 열을
# 첫 번째 묶음의 두 번째 행에
# 세 번째 행의 마지막 열, 마지막 행의 두 번째 열, 첫 번째 행의 첫 번째 열을
# 3차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[[ 1,  8, 15],
        [18, 20,  1]]])
</pre>


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 묶음의 첫 번째 행에 
# 첫 번째 행의 첫 번쨰 열, 두 번째 행의 두 번째 열, 세 번째 행의 마지막 열을
# 첫 번째 묶음의 두 번째 행에
# 세 번째 행의 첫 번째 열, 두 번째 행의 두 번째 열, 첫 번째 행의 마지막 열을
# 3차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[[ 1,  8, 18],
        [13,  8,  6]]])
</pre>


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 묶음의 첫 번째 행에 
# 첫 번째 행의 첫 번쨰 열, 두 번째 행의 첫 번째 열, 세 번째 행의 첫 번째 열을
# 첫 번째 묶음의 두 번째 행에 
# 세 번째 행의 첫 번째 열, 두 번째 행의 첫 번째 열, 첫 번째 행의 첫 번째 열을
# 두 번째 묶음의 첫 번째 행에 
# 첫 번째 행의 마지막 열, 두 번째 행의 마지막 열, 세 번째 행의 마지막 열을
# 두 번째 묶음의 두 번째 행에 
# 세 번째 행의 마지막 열, 두 번째 행의 마지막 열, 첫 번째 행의 마지막 열을
# 3차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[[ 1,  7, 13],
        [13,  7,  1]],

       [[ 6, 12, 18],
        [18, 12,  6]]])
</pre>


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 묶음의 첫 번째 행에 
# 첫 번째 행의 첫 번쨰 열, 두 번째 행의 첫 번째 열, 
# 세 번째 행의 첫 번째 열, 네 번째 행의 첫 번째 열을
# 두 번째 묶음의 첫 번째 행에 
# 첫 번째 행의 두 번째 열, 첫 번째 행의 두 번째 열, 
# 마지막 행의 두 번째 열, 마지막 행의 두 번째 열을
# 3차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[[ 1,  7, 13, 19]],

       [[ 2,  2, 20, 20]]])
</pre>


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 묶음의 첫 번째 행에 
# 첫 번째 행의 첫 번쨰 열, 두 번째 행의 첫 번째 열, 
# 세 번째 행의 첫 번째 열, 네 번째 행의 첫 번째 열을
# 첫 번째 묶음의 두 번째 행에 
# 첫 번째 행의 두 번쨰 열, 두 번째 행의 두 번째 열, 
# 세 번째 행의 두 번째 열, 네 번째 행의 두 번째 열을
# 두 번째 묶음의 첫 번째 행에 
# 첫 번째 행의 첫 번째 열, 첫 번째 행의 첫 번째 열, 
# 마지막 행의 두 번째 열, 마지막 행의 두 번째 열을
# 두 번째 묶음의 두 번째 행에 
# 첫 번째 행의 두 번째 열, 첫 번째 행의 두 번째 열, 
# 마지막 행의 두 번째 열, 마지막 행의 두 번째 열을
# 3차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[[ 1,  7, 13, 19],
        [ 2,  8, 14, 20]],

       [[ 1,  1, 19, 19],
        [ 2,  2, 20, 20]]])
</pre>


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 묶음의 첫 번째 행에 
# 첫 번째 행, 두 번째 행, 세 번째 행, 네 번째 행의 마지막 열을
# 두 번째 묶음의 첫 번째 행에 
# 첫 번째 행, 첫 번째 행, 마지막 행, 마지막 행의 마지막 열을
# 3차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[[ 6, 12, 18, 24]],

       [[ 6,  6, 24, 24]]])
</pre>


```python
# --- arr2의 값을 아래 실행 결과처럼 추출하려면?
# 첫 번째 묶음의 첫 번째 행에 
# 첫 번째 행, 두 번째 행, 세 번째 행, 네 번째 행의 첫 번째 열을,
# 첫 번째 묶음의 두 번째 행에 
# 첫 번째 행, 두 번째 행, 세 번째 행, 네 번째 행의 두 번째 열을,
# 첫 번째 묶음의 세 번째 행에 
# 첫 번째 행, 두 번째 행, 세 번째 행, 네 번째 행의 세 번째 열을,
# 두 번째 묶음의 첫 번째 행에 
# 첫 번째 행, 첫 번째 행, 마지막 행, 마지막 행의 첫 번째 열을,
# 두 번째 묶음의 두 번째 행에
# 첫 번째 행, 첫 번째 행, 마지막 행, 마지막 행의 두 번째 열을,
# 두 번째 묶음의 세 번째 행에
# 첫 번째 행, 첫 번째 행, 마지막 행, 마지막 행의 세 번째 열을
# 3차원 배열로 반환한다.
arr2[__TODO__]  
```

**실행 결과**

<pre>
array([[[ 1,  7, 13, 19],
        [ 2,  8, 14, 20],
        [ 3,  9, 15, 21]],

       [[ 1,  1, 19, 19],
        [ 2,  2, 20, 20],
        [ 3,  3, 21, 21]]])
</pre>

### Lab: 2차원 배열의 3차원 배열 인덱싱

다음 2차원 배열을 3차원 배열 인덱싱으로 했을 때 반환하는 결괏값이 무엇인가?


```python
# 2차원(5, 7) 배열을 만든다. rank = 2
arr2 = numpy.arange(1, 36).reshape(5, 7)
arr2
```




    array([[ 1,  2,  3,  4,  5,  6,  7],
           [ 8,  9, 10, 11, 12, 13, 14],
           [15, 16, 17, 18, 19, 20, 21],
           [22, 23, 24, 25, 26, 27, 28],
           [29, 30, 31, 32, 33, 34, 35]])



#### 문제 1

```python
arr2[numpy.array([[[0, 1]], [[1, 2]], [[2, 3]]]),
     numpy.array([[[0, -1]]])]
```

**답**


```python
# Your answer here
```

#### 문제 2

```python
arr2[numpy.array([[[0, 1]], [[1, 2]], [[2, 3]]]), 
     numpy.array([[[0], [-1]]])]
```     

**답**


```python
# Your answer here
```

#### 문제 3

```python
arr2[numpy.array([[[0, 1]], [[1, 2]], [[2, 3]]]), 
     numpy.array([[[0]], [[-1]], [[1]]])]
```  

**답**


```python
# Your answer here
```

# 분할 연산

## 분할 연산(slicing)이란? : [ : : ]

- 파이썬의 리스트와 유사하게 동작한다.


```python
arr = numpy.arange(1, 10)
arr
```




    array([1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
# > arr = [1 2 3 4 5 6 7 8 9]
# arr의 여섯 번째부터 여덟 번째까지의 값을 추출한다.
arr[5:-1]
```




    array([6, 7, 8])




```python
L = list(range(1, 10))
L[5:-1]
```




    [6, 7, 8]



하지만 다른 부분도 있다.


```python
# > arr = [1 2 3 4 5 6 7 8 9]
# 선택한 범위 전체를 수정한다.
arr[6:] = 99
arr
```




    array([ 1,  2,  3,  4,  5,  6, 99, 99, 99])




```python
# > L = [1, 2, 3, 4, 5, 6, 7, 8, 9]
L[6:] = [99]  # 참고: 99를 할당하면 오류가 난다.
L
```




    [1, 2, 3, 4, 5, 6, 99]



이처럼 분할 연산은 리스트와 다르지만 인덱스는 같은 방식으로 작동한다.


```python
# > L = [1, 2, 3, 4, 5, 6, 99]
L[-1] = 0
L
```




    [1, 2, 3, 4, 5, 6, 0]




```python
# > arr = [ 1  2  3  4  5  6 99 99 99]
arr[-1] = 0
arr
```




    array([ 1,  2,  3,  4,  5,  6, 99, 99,  0])



**[주의]**   
분할하면 반환한 배열은 원본의 복사본이 아니라 원본 배열과 **동일한 객체를 참조**한다.


```python
# > arr = [ 1  2  3  4  5  6 99 99  0]
arr1 = arr
arr1[:5] = -1
arr
```




    array([-1, -1, -1, -1, -1,  6, 99, 99,  0])



따라서 복사본을 갖고 싶다면 **copy()** 를 사용해야 한다.


```python
# > arr = [-1 -1 -1 -1 -1  6 99 99  0]
arr2 = arr.copy()
arr2[:5] = 0
arr
```




    array([-1, -1, -1, -1, -1,  6, 99, 99,  0])




```python
arr2
```




    array([ 0,  0,  0,  0,  0,  6, 99, 99,  0])



## 1차원 배열 분할

- 파이썬의 시퀀스형에서 분할 연산자를 수행하는 것과 같은 방식으로 작동한다.


```python
# 1차원(15,) 배열을 반환한다. rank = 1
arr = numpy.arange(1, 16)
arr
```




    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15])




```python
# arr의 첫 다섯 개의 값을 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([1, 2, 3, 4, 5])
</pre>


```python
# arr의 두 번째([1])부터 열 번째([9])까지 하나씩 건너뛰면서(폭 = 2) 값을 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([ 2,  4,  6,  8, 10])
</pre>


```python
# arr 배열의 값을 뒤집어서 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([15, 14, 13, 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1])
</pre>

## 다차원 배열 분할

- 다차원 배열에서 분할 연산자를 사용하면 여러 개의 행 또는 열을 추출할 수 있다.

### 2차원 배열의 분할 연산


```python
# 2차원(5, 3) 배열이다. rank = 2
arr = numpy.arange(1, 16).reshape(5, 3)
arr
```




    array([[ 1,  2,  3],
           [ 4,  5,  6],
           [ 7,  8,  9],
           [10, 11, 12],
           [13, 14, 15]])




```python
# 분할 연산으로 arr의 첫 두 행을 모두 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([[1, 2, 3],
       [4, 5, 6]])
</pre>


```python
# 분할 연산으로 arr을 거꾸로 마지막, 세 번째, 첫 번째 행에서 첫 번째, 세 번째 열의 값을 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([[13, 15],
       [ 7,  9],
       [ 1,  3]])
</pre>


```python
# arr의 모든 행에서 첫 번째, 마지막, 마지막 열만 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([[ 1,  3,  3],
       [ 4,  6,  6],
       [ 7,  9,  9],
       [10, 12, 12],
       [13, 15, 15]])
</pre>


```python
# arr의 첫 번째, 마지막, 두 번째 행에서 마지막 열만 추출한다. rank = 1(정수 인덱스 사용)
__TODO__
```

**실행 결과**

<pre>
array([ 3, 15,  6])
</pre>


```python
# arr의 첫 번째, 마지막, 두 번째 행에서 마지막 열만 추출한다. rank = 2(둘 다 분할 연산)
__TODO__
```

**실행 결과**

<pre>
array([[ 3],
       [15],
       [ 6]])
</pre>

### 3차원 배열의 분할 연산


```python
# 3차원(2, 3, 4) 배열이다. rank = 3
arr = numpy.arange(1, 25).reshape(2, 3, 4)
arr
```




    array([[[ 1,  2,  3,  4],
            [ 5,  6,  7,  8],
            [ 9, 10, 11, 12]],
    
           [[13, 14, 15, 16],
            [17, 18, 19, 20],
            [21, 22, 23, 24]]])




```python
# 분할 연산으로 arr의 첫 번째 묶음의 모든 행을 마지막 열부터 거꾸로 모두 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([[[ 4,  3,  2,  1],
        [ 8,  7,  6,  5],
        [12, 11, 10,  9]]])
</pre>


```python
# arr의 모든 묶음의 첫 번째, 마지막, 마지막 행에서 마지막 열만 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([[ 4, 12, 12],
       [16, 24, 24]])
</pre>


```python
# arr의 첫 번째 묶음의 첫 번째, 세 번째 행에서 마지막 열을 추출하여 3차원 배열의 첫 번째 묶음과 두 번째 묶음으로 반환한다.
__TODO__
```

**실행 결과**

<pre>
array([[[ 4],
        [12]],

       [[ 4],
        [12]]])
</pre>

### 분할 연산과 정수 인덱스를 함께 사용할 때와 분할 연산만 할 때의 차이

- 분할 연산만 하면 원본과 **같은 차원**(rank)의 배열을 반환한다.
- 분할 연산과 정수 인덱스를 같이 사용하면 원본보다 **낮은 차원**(rank)의 배열을 반환한다.


```python
# arr의 첫 번째 묶음만 추출해서 1차원 배열을 만든다. rank = 1(정수 인덱스 사용)
__TODO__
```

**실행 결과**

<pre>
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
</pre>


```python
# arr의 첫 번째 묶음만 추출해서 3차원 배열을 만든다. rank = 3(둘 다 분할 연산)
__TODO__
```

**실행 결과**

<pre>
array([[[ 1,  2,  3,  4],
        [ 5,  6,  7,  8],
        [ 9, 10, 11, 12]]])
</pre>


```python
# arr의 각 묶음에서 첫 번째 행만 추출해서 2차원 배열을 만든다. rank = 2(정수 인덱스 사용)
__TODO__
```

**실행 결과**

<pre>
array([[ 1,  2,  3,  4],
       [13, 14, 15, 16]])
</pre>


```python
# arr의 각 묶음에서 첫 번째 행만 추출해서 3차원 배열을 만든다. rank = 3(둘 다 분할 연산)
__TODO__
```

**실행 결과**

<pre>
array([[[ 1,  2,  3,  4]],

       [[13, 14, 15, 16]]])
</pre>


```python
# arr의 두 번째 묶음과 첫 번째 묶음에서 마지막 행만 추출해서 2차원 배열을 만든다. rank = 2(정수 인덱스 사용)
__TODO__
```

**실행 결과**

<pre>
array([[21, 22, 23, 24],
       [ 9, 10, 11, 12]])
</pre>


```python
# arr의 두 번째 묶음과 첫 번째 묶음에서 마지막 행만 추출해서 3차원 배열을 만든다. rank = 3(둘 다 분할 연산)
__TODO__
```

**실행 결과**

<pre>
array([[[21, 22, 23, 24]],

       [[ 9, 10, 11, 12]]])
</pre>


```python
# arr의 두 번째 묶음과 첫 번째 묶음에서 각각 첫 번째와 마지막 행을 추출해서 3차원 배열을 만든다. rank = 3(둘 다 분할 연산)
__TODO__
```

**실행 결과**

<pre>
array([[[13, 14, 15, 16],
        [21, 22, 23, 24]],

       [[ 1,  2,  3,  4],
        [ 9, 10, 11, 12]]])
</pre>

## 다차원 배열의 부분 분할

### 2차원 배열의 부분 분할


```python
# 2차원(5, 3) 배열이다. rank = 2
arr = numpy.arange(1, 16).reshape(5, 3)
arr
```




    array([[ 1,  2,  3],
           [ 4,  5,  6],
           [ 7,  8,  9],
           [10, 11, 12],
           [13, 14, 15]])




```python
# 분할 연산으로 arr의 두 번째 행부터 네 번째 행까지의 모든 열을 추출한다.  
__TODO__
```

**실행 결과**

<pre>
array([[ 4,  5,  6],
       [ 7,  8,  9],
       [10, 11, 12]])
</pre>


```python
# 분할 연산으로 arr의 마지막 행부터 첫 번째 행까지 하나씩 거꾸로 건너뛰면서(폭 = -2) 
# 행 전체를 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([[13, 14, 15],
       [ 7,  8,  9],
       [ 1,  2,  3]])
</pre>

### 3차원 배열의 부분 분할


```python
# 3차원(2, 3, 4) 배열이다. rank = 3
arr = numpy.arange(1, 25).reshape(2, 3, 4)
arr
```




    array([[[ 1,  2,  3,  4],
            [ 5,  6,  7,  8],
            [ 9, 10, 11, 12]],
    
           [[13, 14, 15, 16],
            [17, 18, 19, 20],
            [21, 22, 23, 24]]])




```python
# 분할 연산으로 arr의 첫 번째 묶음의 마지막, 첫 번째 행의 모든 열을 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([[ 9, 10, 11, 12],
       [ 1,  2,  3,  4]])
</pre>

# 불린 배열 인덱싱

## 불린 배열 인덱싱이란?

**불린 배열 인덱싱**(Booelan array indexing)이란?

- 행 또는 열의 수와 같은 논리형 배열을 인덱스로 사용하여 특정 값만 선택할 수 있다.
- 불린 배열은 인덱싱 할 배열의 차원과 같은 차원 형태(shape)여야 한다.
- 따라서, 배열 인덱싱과는 다른 방식으로 다뤄진다.


```python
# 2차원(3,5) 배열을 만든다. rank = 2
arr = numpy.arange(1, 16).reshape(3, 5)
arr
```




    array([[ 1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10],
           [11, 12, 13, 14, 15]])




```python
# 불린 배열 인덱싱으로 arr의 첫 번째와 세 번째 행을 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([[ 1,  2,  3,  4,  5],
       [11, 12, 13, 14, 15]])
</pre>


```python
# 불린 배열 인덱싱으로 arr의 첫 번째와 세 번째 열을 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([[ 1,  3],
       [ 6,  8],
       [11, 13]])
</pre>


```python
# 불린 배열 인덱싱으로 첫 번째, 마지막 행에서 첫 번째 열만 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([ 1, 11])
</pre>


```python
# 불린 배열 인덱싱으로 첫 번째 행의 첫 번째 열, 마지막 행의 네 번째 열만 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([ 1, 14]
</pre>


```python
# 불린 배열 인덱싱으로 첫 번째와 마지막 행에서 첫 번째 열과 네 번째 열을 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([[ 1,  4],
       [11, 14]])
</pre>


```python
# > arr = [[ 1  2  3  4  5]  # 2차원 배열(3, 5)이다.
#          [ 6  7  8  9 10]
#          [11 12 13 14 15]]

# 불린 배열 인덱싱으로 첫 번째와 마지막 행에서 첫 번째 열과 네 번째 열을 추출한다.
# arr[[True, False, True], :][:, [0, 3]]와 같다.
arr[numpy.array([True, False, True])][:, numpy.array([0, 3])]  
# arr[numpy.array([True, False, True])][:, numpy.array([True, False, False, True, False])]와 같다.
```




    array([[ 1,  4],
           [11, 14]])




```python
# arr의 값 중 9보다 큰 값을 불린 배열로 구성한다.
bidx = __TODO__

# 불린 배열은 인덱싱할 배열의 차원과 같은 차원 형태(3, 5)이다.
bidx  
```

**실행 결과**

<pre>
array([[False, False, False, False, False],
       [False, False, False, False,  True],
       [ True,  True,  True,  True,  True]])
</pre>


```python
# bidx로 불린 배열 인덱싱하여 arr의 값 중 9보다 큰 값들을 추출한다.
arr[__TODO__]
```

**실행 결과**

<pre>
array([10, 11, 12, 13, 14, 15])
</pre>


```python
# bidx의 모든 행에서 마지막 열만 추출하여 1차원 불린 배열(3,)을 만든다.
bidx2 = __TODO__
bidx2
```

**실행 결과**

<pre>
array([False,  True,  True])
</pre>


```python
# 1차원 불린 배열(3,)을 이용하여 2차원 배열(3, 5)의 행에 적용한다.
# bidx2로 불린 배열 인덱싱하여 arr의 두 번째, 세 번째 행을 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([[ 6,  7,  8,  9, 10],
       [11, 12, 13, 14, 15]])
</pre>


```python
# bidx의 두 번째 행만 추출하여 1차원 불린 배열(5,)을 만든다.
bidx3 = __TODO__
bidx3
```

**실행 결과**

<pre>
array([False, False, False, False,  True])
</pre>


```python
# 1차원 불린 배열(5,)을 이용하여 2차원 배열(3, 5)의 열에 적용한다.
# bidx3으로 불린 배열 인덱싱하여 arr의 모든 행에서 마지막 열을 추출한다.
__TODO__
```

**실행 결과**

<pre>
array([[ 5],
       [10],
       [15]])
</pre>

## 다차원 배열에서 부분 불린 인덱싱

- 불린 배열 인덱스의 차원이 인덱싱할 배열의 차원보다 낮다면, 낮은 차원에 속한 배열은 분할 연산자 <b>[:]</b>를 사용해 낮은 차원의 배열에 속한 모든 값을 추출하는 것과 같은 결과를 가져온다.
- 반환한 배열의 차원 형태(shape)는 
    + **2차원**의 경우는 (배열 인덱스에서 사용한 인덱스 총 개수, 행의 크기)가 된다.     
    + **3차원**의 경우는 (배열 인덱스에서 사용한 인덱스 총 개수, 행의 총 개수, 행의 크기)가 된다.     

<!-- 
- 일반적으로 반환하는 배열의 차원 형태는 배열 인텍스의 차원 형태와 인덱싱 하지 않은 차원의 차원 형태를 합친 것과 같다.
-->


```python
# 3차원(2, 3, 4) 배열이다. rank = 3
arr = numpy.arange(1, 25).reshape(2, 3, 4)
arr
```




    array([[[ 1,  2,  3,  4],
            [ 5,  6,  7,  8],
            [ 9, 10, 11, 12]],
    
           [[13, 14, 15, 16],
            [17, 18, 19, 20],
            [21, 22, 23, 24]]])




```python
# >3차원(2, 3, 4) 배열이다.
# > arr = [[[ 1  2  3  4]
#           [ 5  6  7  8]
#           [ 9 10 11 12]]
#
#          [[13 14 15 16]
#           [17 18 19 20]
#           [21 22 23 24]]]

bidx = numpy.array([True, False])
arr[bidx]
```




    array([[[ 1,  2,  3,  4],
            [ 5,  6,  7,  8],
            [ 9, 10, 11, 12]]])



- - -

# THE END
