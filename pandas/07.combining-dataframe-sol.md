- - -

# 판다스 입문 : 데이터프레임 합치기

### Pandas Primer: Combining DataFrame

* * *

**박 진 수** 교수  
Intelligent Data Semantics Lab  
Seoul National University

- - -

<h3>Table of Contents<span class="tocSkip"></span></h3>
<div class="toc"><ul class="toc-item"><li><span><a href="#concat-메소드" data-toc-modified-id="concat-메소드-1"><strong>concat</strong> 메소드</a></span><ul class="toc-item"><li><span><a href="#축을-따로-설정하지-않는-경우(axis=0/index)" data-toc-modified-id="축을-따로-설정하지-않는-경우(axis=0/index)-1.1">축을 따로 설정하지 않는 경우(axis=0/index)</a></span><ul class="toc-item"><li><span><a href="#인덱스와-열-이름이-같은-경우" data-toc-modified-id="인덱스와-열-이름이-같은-경우-1.1.1">인덱스와 열 이름이 같은 경우</a></span></li><li><span><a href="#인덱스와-열-이름이-다른-경우" data-toc-modified-id="인덱스와-열-이름이-다른-경우-1.1.2">인덱스와 열 이름이 다른 경우</a></span></li></ul></li><li><span><a href="#축을-1로-설정하는-경우(axis=1/columns)" data-toc-modified-id="축을-1로-설정하는-경우(axis=1/columns)-1.2">축을 1로 설정하는 경우(axis=1/columns)</a></span><ul class="toc-item"><li><span><a href="#인덱스와-열-이름이-같은-경우" data-toc-modified-id="인덱스와-열-이름이-같은-경우-1.2.1">인덱스와 열 이름이 같은 경우</a></span></li><li><span><a href="#인덱스와-열-이름이-다른-경우" data-toc-modified-id="인덱스와-열-이름이-다른-경우-1.2.2">인덱스와 열 이름이 다른 경우</a></span></li></ul></li><li><span><a href="#그룹-키를-사용한-결합" data-toc-modified-id="그룹-키를-사용한-결합-1.3">그룹 키를 사용한 결합</a></span></li><li><span><a href="#인덱스-중복-값-확인" data-toc-modified-id="인덱스-중복-값-확인-1.4">인덱스 중복 값 확인</a></span></li></ul></li><li><span><a href="#merge()-메소드" data-toc-modified-id="merge()-메소드-2"><strong>merge()</strong> 메소드</a></span><ul class="toc-item"><li><span><a href="#인덱스와-열-이름이-모두-같지만-병합-열을-지정하지-않은-경우" data-toc-modified-id="인덱스와-열-이름이-모두-같지만-병합-열을-지정하지-않은-경우-2.1">인덱스와 열 이름이 모두 같지만 병합 열을 지정하지 않은 경우</a></span><ul class="toc-item"><li><span><a href="#중복-값이-없는-경우" data-toc-modified-id="중복-값이-없는-경우-2.1.1">중복 값이 없는 경우</a></span></li><li><span><a href="#한-행-전체의-값이-같은-경우" data-toc-modified-id="한-행-전체의-값이-같은-경우-2.1.2">한 행 전체의 값이 같은 경우</a></span></li><li><span><a href="#일부-값이-같은-경우" data-toc-modified-id="일부-값이-같은-경우-2.1.3">일부 값이 같은 경우</a></span></li></ul></li><li><span><a href="#중복-키와-Cartesian-product" data-toc-modified-id="중복-키와-Cartesian-product-2.2">중복 키와 Cartesian product</a></span><ul class="toc-item"><li><span><a href="#병합-열의-이름이-같은-경우와-다른-경우" data-toc-modified-id="병합-열의-이름이-같은-경우와-다른-경우-2.2.1">병합 열의 이름이 같은 경우와 다른 경우</a></span><ul class="toc-item"><li><span><a href="#병합-열을-지정하지-않는-경우" data-toc-modified-id="병합-열을-지정하지-않는-경우-2.2.1.1">병합 열을 지정하지 않는 경우</a></span></li><li><span><a href="#병합-열을-지정하는-경우" data-toc-modified-id="병합-열을-지정하는-경우-2.2.1.2">병합 열을 지정하는 경우</a></span></li></ul></li></ul></li><li><span><a href="#Cardinality" data-toc-modified-id="Cardinality-2.3">Cardinality</a></span><ul class="toc-item"><li><span><a href="#일대일" data-toc-modified-id="일대일-2.3.1">일대일</a></span></li><li><span><a href="#일대다" data-toc-modified-id="일대다-2.3.2">일대다</a></span></li><li><span><a href="#다대일" data-toc-modified-id="다대일-2.3.3">다대일</a></span></li><li><span><a href="#다대다" data-toc-modified-id="다대다-2.3.4">다대다</a></span></li></ul></li></ul></li><li><span><a href="#merge()-vs.-concat-vs.-join" data-toc-modified-id="merge()-vs.-concat-vs.-join-3"><strong>merge()</strong> vs. <strong>concat</strong> vs. <strong>join</strong></a></span><ul class="toc-item"><li><span><a href="#merge()-메소드" data-toc-modified-id="merge()-메소드-3.1"><strong>merge()</strong> 메소드</a></span></li><li><span><a href="#concat-메소드" data-toc-modified-id="concat-메소드-3.2"><strong>concat</strong> 메소드</a></span></li><li><span><a href="#join-메소드" data-toc-modified-id="join-메소드-3.3"><strong>join</strong> 메소드</a></span></li><li><span><a href="#Inner-join" data-toc-modified-id="Inner-join-3.4">Inner join</a></span><ul class="toc-item"><li><span><a href="#인덱스가-같은-경우" data-toc-modified-id="인덱스가-같은-경우-3.4.1">인덱스가 같은 경우</a></span></li><li><span><a href="#인덱스가-다른-경우" data-toc-modified-id="인덱스가-다른-경우-3.4.2">인덱스가 다른 경우</a></span></li></ul></li><li><span><a href="#Outer-join" data-toc-modified-id="Outer-join-3.5">Outer join</a></span><ul class="toc-item"><li><span><a href="#인덱스가-같은-경우" data-toc-modified-id="인덱스가-같은-경우-3.5.1">인덱스가 같은 경우</a></span></li><li><span><a href="#인덱스가-다른-경우" data-toc-modified-id="인덱스가-다른-경우-3.5.2">인덱스가 다른 경우</a></span></li></ul></li></ul></li></ul></div>


```python
import pandas, numpy

print('Pandas version...:', pandas.__version__)
print('NumPy version....:', numpy.__version__)
```


데이터프레임을 결합한다. 즉, 두 개 이상의 데이터프레임을 단순히 합칠 때 사용하는 메소드다.
- pandas.**concat([DataFrame/Series1, DataFrame/Series2,...], axis='index')**
- **동종** 형태의 자료형으로 구성된 리스트나 딕셔너리 형태의 데이터프레임이나 시리즈를 받아서 이들을 결합한다.
- 오래된 시리즈/데이터프레임의 **append** 메소드보다 권장하는 방식이다.
- **concat** 메소드/**append** 메소: 데이터의 전체 복사본을 만들어 반환하기 때문에, 이 메소드를 지속적으로 사용하면 
- 상당한 
- 성능 저하가 발생할 수 있다는 점에 유의하자.

[pandas.concat](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html#pandas.concat)
- Concatenate pandas objects along a particular axis with optional set logic along the other axes.
- Can also add a layer of hierarchical indexing on the concatenation axis, which may be useful if the labels are the same (or overlapping) on the passed axis number.
- pandas.**concat**(*objs, axis=0, join='outer', join_axes=None, ignore_index=False, keys=None, levels=None, names=None, verify_integrity=False, sort=None, copy=True*)
    - ***objs*** : *a sequence or mapping of Series or DataFrame objects*
        - If a *dict* is passed, the sorted keys will be used as the keys argument, unless it is passed, in which case the values will be selected. Any None objects will be dropped silently unless they are all None in which case a ValueError will be raised.
    - ***axis*** : {0/*'index'*, 1/*'columns'*}, default 0
        - The axis to concatenate along
    - ***join*** : {*'inner'*, *'outer'*}, default ‘outer’
        - How to handle indexes on other axis(es)
    - ***ignore_index*** : *bool*, default False
        - If *True*, do not use the index values along the concatenation axis. The resulting axis will be labeled 0, …, n - 1. This is useful if you are concatenating objects where the concatenation axis does not have meaningful indexing information. Note the index values on the other axes are still respected in the join.  
    - ***keys*** : *sequence*, default None
        - If multiple levels passed, should contain tuples. Construct hierarchical index using the passed keys as the outermost level.
    - ***levels*** : *list of sequences*, default None
        - Specific levels (unique values) to use for constructing a MultiIndex. Otherwise they will be inferred from the keys.
    - ***names*** : *list*, default None
        - Names for the levels in the resulting hierarchical index.
    - ***verify_integrity*** : *bool*, default False
        - Check whether the new concatenated axis contains duplicates. This can be very expensive relative to the actual data concatenation.
    - ***sort*** : *bool*, default None
        - Sort non-concatenation axis if it is not already aligned **when join is 'outer'**. The current default of sorting is deprecated and will change to not-sorting in a future version of pandas.
        - Explicitly pass ***sort=True*** to silence the warning and sort. Explicitly pass sort=False to silence the warning and not sort.
        - This has **no effect when join='inner'**, which already preserves the order of the non-concatenation axis.
    - Returns:	
        - concatenated : *object, type of objs*
            - When concatenating all **Series** along the **index (*axis=0*)**, a **Series** is returned. When **objs** contains at least one **DataFrame**, a **DataFrame** is returned. When concatenating along the **columns (*axis=1*)**, a **DataFrame** is returned.

## 축을 따로 설정하지 않는 경우(axis=0/index)

행을 결합한다.
- 기본값은 **outer join**이다.

### 인덱스와 열 이름이 같은 경우


```python
df1 = pandas.DataFrame([[1, 2, 3], [4, 5, 6]], 
                       index=list('ab'),
                       columns=list('ABC'))

df2 = pandas.DataFrame([[4, 5, 6], [7, 8, 9]],
                       index=list('ab'),
                       columns=list('ABC'))                   
```


```python
print(df1)
```

       A  B  C
    a  1  2  3
    b  4  5  6



```python
print(df2)
```

       A  B  C
    a  4  5  6
    b  7  8  9


**=== Outer join (union) =======**

**df1** / **df2**
<pre>
   A  B  C
a  1  2  3
b  4  5  6

   A  B  C
a  4  5  6
b  7  8  9
</pre>


```python
# df1과 df2를 기본값(outer join)으로 결합한다.
# axis='index'/0은 기본값이라 생략할 수 있다.
print(pandas.concat([df1, df2]))
```

       A  B  C
    a  1  2  3
    b  4  5  6
    a  4  5  6
    b  7  8  9



```python
# 결합 축의 인덱스를 무시한다. 
# 즉, df1과 df2의 기존 인덱스를 무시하고 인덱스의 기본값을 사용한다.
print(pandas.concat([df1, df2], ignore_index=True))
```

       A  B  C
    0  1  2  3
    1  4  5  6
    2  4  5  6
    3  7  8  9



```python
# 매개변수 keys를 사용하여 df1과 df2를 다중 인덱스로 결합한다.
df_keys = pandas.concat([df1, df2], keys=['table1', 'table2'])
print(df_keys)
```

              A  B  C
    table1 a  1  2  3
           b  4  5  6
    table2 a  4  5  6
           b  7  8  9



```python
# df_keys의 인덱스를 열람한다.
df_keys.index
```




    MultiIndex([('table1', 'a'),
                ('table1', 'b'),
                ('table2', 'a'),
                ('table2', 'b')],
               )



[pandas.MultiIndex.get_level_values](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.MultiIndex.get_level_values.html)
- Return an Index of values for requested level.
- *MultiIndex*.**get_level_values**(*self, level*)
    + ***level*** : *int or str*
        - ***level*** is either the integer position of the level in the MultiIndex, or the name of the level.


```python
# 다중 인데스의 첫 번째 레벨 인덱스를 열람한다.
df_keys.index.get_level_values(0)
```




    Index(['table1', 'table1', 'table2', 'table2'], dtype='object')




```python
# 다중 인데스에서 두 번째 레벨 인덱스를 열람한다.
df_keys.index.get_level_values(1)
```




    Index(['a', 'b', 'a', 'b'], dtype='object')



**=== Inner join (intersection) =======**

**df1** / **df2**
<pre>
   A  B  C
a  1  2  3
b  4  5  6

   A  B  C
a  4  5  6
b  7  8  9
</pre>


```python
# df1과 df2를 inner join으로 결합한다.
# 인덱스와 열 이름이 같기 때문에 outer join과 결과는 같다.
print(pandas.concat([df1, df2], join='inner'))
```

       A  B  C
    a  1  2  3
    b  4  5  6
    a  4  5  6
    b  7  8  9



```python
# df1과 df2를 inner join으로 결합한다.
# 결합 축의 인덱스를 무시한다. 
# 즉, df1과 df2의 기존 인덱스를 무시하고 인덱스의 기본값을 사용한다.
print(pandas.concat([df1, df2], join='inner', ignore_index=True))
```

       A  B  C
    0  1  2  3
    1  4  5  6
    2  4  5  6
    3  7  8  9


### 인덱스와 열 이름이 다른 경우


```python
df3 = pandas.DataFrame(numpy.arange(1, 13).reshape(4, 3),
                       index=list('abcd'),
                       columns=list('ABC'))

df4 = pandas.DataFrame(numpy.arange(7, 19).reshape(4, 3),
                       index=list('abxy'),
                       columns=list('ABD'))
```


```python
print(df3)
```

        A   B   C
    a   1   2   3
    b   4   5   6
    c   7   8   9
    d  10  11  12



```python
print(df4)
```

        A   B   D
    a   7   8   9
    b  10  11  12
    x  13  14  15
    y  16  17  18


**=== Outer join (union) =======**

행 축을 기준으로 기본값인 **'outer'** 결합을 하면(합집합), 모든 행을 포함하지만 원래 속하지 않는 행의 값은 NaN로 채운다.

**df3** / **df4**
<pre>
    A   B   C
a   1   2   3
b   4   5   6
c   7   8   9
d  10  11  12

    A   B   D
a   7   8   9
b  10  11  12
x  13  14  15
y  16  17  18
</pre>


```python
# df3과 df4를 기본값(outer join)으로 결합한다.
# axis='index'/0은 기본값이라 생략할 수 있다.
print(pandas.concat([df3, df4], axis='index'))
```

        A   B     C     D
    a   1   2   3.0   NaN
    b   4   5   6.0   NaN
    c   7   8   9.0   NaN
    d  10  11  12.0   NaN
    a   7   8   NaN   9.0
    b  10  11   NaN  12.0
    x  13  14   NaN  15.0
    y  16  17   NaN  18.0



```python
# df3과 df4를 기본값(outer join)으로 결합한다.
# 결합 축의 인덱스를 무시한다. 
# 즉, df3과 df4의 기존 인덱스를 무시하고 인덱스의 기본값을 사용한다.
print(pandas.concat([df3, df4], ignore_index=True))
```

        A   B     C     D
    0   1   2   3.0   NaN
    1   4   5   6.0   NaN
    2   7   8   9.0   NaN
    3  10  11  12.0   NaN
    4   7   8   NaN   9.0
    5  10  11   NaN  12.0
    6  13  14   NaN  15.0
    7  16  17   NaN  18.0


**=== Inner join (intersection) =======**

행 축을 기준으로 **'inner'** 결합을 하면(교집합), 이름이 같은 행만 결합한다.

**df3** / **df4**
<pre>
    A   B   C
a   1   2   3
b   4   5   6
c   7   8   9
d  10  11  12

    A   B   D
a   7   8   9
b  10  11  12
x  13  14  15
y  16  17  18
</pre>


```python
# df3과 df4를 inner join으로 결합한다.
print(pandas.concat([df3, df4], join='inner'))
```

        A   B
    a   1   2
    b   4   5
    c   7   8
    d  10  11
    a   7   8
    b  10  11
    x  13  14
    y  16  17



```python
# df3과 df4를 inner join으로 결합한다.
# 결합 축의 인덱스를 무시한다. 
# 즉, df3과 df4의 기존 인덱스를 무시하고 인덱스의 기본값을 사용한다.
print(pandas.concat([df3, df4], join='inner', ignore_index=True))
```

        A   B
    0   1   2
    1   4   5
    2   7   8
    3  10  11
    4   7   8
    5  10  11
    6  13  14
    7  16  17


## 축을 1로 설정하는 경우(axis=1/columns)

열(컬럼)을 결합한다.
- 디폴트는 **outer join**이다.

### 인덱스와 열 이름이 같은 경우


```python
df1 = pandas.DataFrame([[1, 2, 3], [4, 5, 6]],
                       index=list('ab'),
                       columns=list('ABC'))

df2 = pandas.DataFrame([[4, 5, 6], [7, 8, 9]],
                       index=list('ab'),
                       columns=list('ABC'))                   
```


```python
print(df1)
```

       A  B  C
    a  1  2  3
    b  4  5  6



```python
print(df2)
```

       A  B  C
    a  4  5  6
    b  7  8  9


**=== Outer join(union) =======**

**df1** / **df2**
<pre>
   A  B  C
a  1  2  3
b  4  5  6

   A  B  C
a  4  5  6
b  7  8  9
</pre>


```python
# df1과 df2의 열(컬럼)을 결합 축으로 하고 기본값(outer join)으로 결합한다.
print(pandas.concat([df1, df2], axis='columns'))
```

       A  B  C  A  B  C
    a  1  2  3  4  5  6
    b  4  5  6  7  8  9



```python
# df1과 df2의 열(컬럼)을 결합 축으로 하고 기본값(outer join)으로 결합한다.
# 결합 축의 인덱스를 무시한다. 
# 즉, df1과 df2의 기존 인덱스를 무시하고 인덱스의 기본값을 사용한다.
print(pandas.concat([df1, df2], axis=1, ignore_index=True))
```

       0  1  2  3  4  5
    a  1  2  3  4  5  6
    b  4  5  6  7  8  9


**=== Inner join (intersection) =======**

**df1** / **df2**
<pre>
   A  B  C
a  1  2  3
b  4  5  6

   A  B  C
a  4  5  6
b  7  8  9
</pre>


```python
# df1과 df2의 열(컬럼)을 결합 축으로 하고 inner join으로 결합한다.
# 인덱스와 열 이름이 같기 때문에 outer join과 결과는 같다.
print(pandas.concat([df1, df2], axis='columns', join='inner'))
```

       A  B  C  A  B  C
    a  1  2  3  4  5  6
    b  4  5  6  7  8  9



```python
# df1과 df2의 열(컬럼)을 결합 축으로 하고 inner join으로 결합한다.
# 결합 축의 인덱스를 무시한다. 
# 즉, df1과 df2의 기존 인덱스를 무시하고 인덱스의 기본값을 사용한다.
print(pandas.concat([df1, df2], axis=1, join='inner', ignore_index=True))
```

       0  1  2  3  4  5
    a  1  2  3  4  5  6
    b  4  5  6  7  8  9


### 인덱스와 열 이름이 다른 경우


```python
df3 = pandas.DataFrame(numpy.arange(1, 13).reshape(4, 3),
                       index=list('abcd'),
                       columns=list('ABC'))

df4 = pandas.DataFrame(numpy.arange(7, 19).reshape(4, 3),
                       index=list('abxy'),
                       columns=list('ABD'))
```


```python
print(df3)
```

        A   B   C
    a   1   2   3
    b   4   5   6
    c   7   8   9
    d  10  11  12



```python
print(df4)
```

        A   B   D
    a   7   8   9
    b  10  11  12
    x  13  14  15
    y  16  17  18


**=== Outer join (union) =======**

열 축을 기준으로 기본값인 **'outer'** 결합을 하면(합집합), 모든 열을 포함하지만 원래 속하지 않는 열의 값는 NaN로 채운다.

**df3** / **df4**
<pre>
    A   B   C
a   1   2   3
b   4   5   6
c   7   8   9
d  10  11  12

    A   B   D
a   7   8   9
b  10  11  12
x  13  14  15
y  16  17  18
</pre>


```python
# df3과 df4의 열(컬럼)을 결합 축으로 하고 기본값(outer join)으로 결합한다.
print(pandas.concat([df3, df4], axis=1))
```

          A     B     C     A     B     D
    a   1.0   2.0   3.0   7.0   8.0   9.0
    b   4.0   5.0   6.0  10.0  11.0  12.0
    c   7.0   8.0   9.0   NaN   NaN   NaN
    d  10.0  11.0  12.0   NaN   NaN   NaN
    x   NaN   NaN   NaN  13.0  14.0  15.0
    y   NaN   NaN   NaN  16.0  17.0  18.0



```python
# df3과 df4의 열(컬럼)을 결합 축으로 하고 기본값(outer join)으로 결합한다.
# 결합 축의 인덱스를 무시한다. 
# 즉, df3과 df4의 기존 인덱스를 무시하고 인덱스의 기본값을 사용한다.
print(pandas.concat([df3, df4], axis=1, ignore_index=True))
```

          0     1     2     3     4     5
    a   1.0   2.0   3.0   7.0   8.0   9.0
    b   4.0   5.0   6.0  10.0  11.0  12.0
    c   7.0   8.0   9.0   NaN   NaN   NaN
    d  10.0  11.0  12.0   NaN   NaN   NaN
    x   NaN   NaN   NaN  13.0  14.0  15.0
    y   NaN   NaN   NaN  16.0  17.0  18.0


**=== Inner join (intersection) =======**

행 축을 기준으로 **'inner'** 결합을 하면(교집합), 이름이 같은 행만 결합한다.

**df3** / **df4**
<pre>
    A   B   C
a   1   2   3
b   4   5   6
c   7   8   9
d  10  11  12

    A   B   D
a   7   8   9
b  10  11  12
x  13  14  15
y  16  17  18
</pre>


```python
# df3과 df4의 열(컬럼)을 결합 축으로 하고 inner join으로 결합한다.
print(pandas.concat([df3, df4], axis='columns', join='inner'))
```

       A  B  C   A   B   D
    a  1  2  3   7   8   9
    b  4  5  6  10  11  12



```python
# df3과 df4의 열(컬럼)을 결합 축으로 하고 inner join으로 결합한다.
# 결합 축의 인덱스를 무시한다. 
# 즉, df3과 df4의 기존 인덱스를 무시하고 인덱스의 기본값을 사용한다.
print(pandas.concat([df3, df4], axis='columns', join='inner', ignore_index=True))
```

       0  1  2   3   4   5
    a  1  2  3   7   8   9
    b  4  5  6  10  11  12


## 그룹 키를 사용한 결합

매개변수 ***keys*** 의 전달인자로 기존의 인덱스나 열 이름을 바꿀 수 있다.


```python
s1 = pandas.Series(['a', 'b', 'c'])
s2 = pandas.Series(['d', 'e', 'f'], name='B')
s3 = pandas.Series(['g', 'h', 'i'])
```


```python
print(s1)
```

    0    a
    1    b
    2    c
    dtype: object



```python
print(s2)
```

    0    d
    1    e
    2    f
    Name: B, dtype: object



```python
print(s3)
```

    0    g
    1    h
    2    i
    dtype: object


**=== 열 축 결합  =======**


```python
# 열 축을 결합한다.
# s1, s2, s3의 열(컬럼)을 결합 축으로 하고 outer join으로 결합한다.
print(pandas.concat([s1, s2, s3], axis=1))
```

       0  B  1
    0  a  d  g
    1  b  e  h
    2  c  f  i


***keys*** 의 가장 흔한 사용 예는 열 이름을 바꾸는 것이다.


```python
# 매개변수 keys로 다음과 같이 열 이름을 바꾼다.
print(pandas.concat([s1, s2, s3], axis=1, 
                    keys=['alfa', 'bravo', 'charlie']))
```

      alfa bravo charlie
    0    a     d       g
    1    b     e       h
    2    c     f       i


**=== 행 축 결합 =======**


```python
# 행 축 결합을 한다.
pandas.concat([s1, s2, s3])
```




    0    a
    1    b
    2    c
    0    d
    1    e
    2    f
    0    g
    1    h
    2    i
    dtype: object



***keys*** 를 사용하여 다중 인덱스로 결합한다.


```python
# keys를 사용해서 행 축을 다음과 같은 다중 인덱스로 결합한다.
pandas.concat([s1, s2, s3], keys=['s1', 's2', 's3'])
```




    s1  0    a
        1    b
        2    c
    s2  0    d
        1    e
        2    f
    s3  0    g
        1    h
        2    i
    dtype: object




```python
# keys를 사용해서 행 축을 다음과 같은 다중 인덱스로 결합한다.
pandas.concat([s1, s2, s3], keys=['y', 'x'])
```




    y  0    a
       1    b
       2    c
    x  0    d
       1    e
       2    f
    dtype: object



매개변수 ***names*** 의 전달인자로 인덱스의 이름을 설정할 수 있다.


```python
# 매개변수 keys와 names를 사용해서 다음과 같이 행 축 결합을 한다.
pandas.concat([s1, s2, s3], 
              keys=['s1', 's2', 's3'], 
              names=['Series Name', 'Row ID'])
```




    Series Name  Row ID
    s1           0         a
                 1         b
                 2         c
    s2           0         d
                 1         e
                 2         f
    s3           0         g
                 1         h
                 2         i
    dtype: object




```python
# --- [참고] 딕셔너리의 키를 keys의 전달인자로 사용
d = {'x': s1, 'y': s2, 'z': s3}
pandas.concat(d)
```




    x  0    a
       1    b
       2    c
    y  0    d
       1    e
       2    f
    z  0    g
       1    h
       2    i
    dtype: object




```python
# keys를 사용해서 행 축 결합을 한다.
pandas.concat(d, keys=['y', 'x'])
```




    y  0    d
       1    e
       2    f
    x  0    a
       1    b
       2    c
    dtype: object



## 인덱스 중복 값 확인


```python
df1 = pandas.DataFrame(numpy.arange(1, 7).reshape(3, 2),
                       columns=list('AB'))

df2 = pandas.DataFrame(numpy.arange(1, 7).reshape(3, 2),
                       index=[1, 2, 3],
                       columns=['B', 'C'])
```


```python
print(df1)
```

       A  B
    0  1  2
    1  3  4
    2  5  6



```python
print(df2)
```

       B  C
    1  1  2
    2  3  4
    3  5  6


매개변수 ***verify_integrity*** 를 사용하여 인덱스의 값이 중복되는지 여부를 확인할 수 있다.

**df1** / **df2**
<pre>
   A  B
0  1  2
1  3  4
2  5  6

   B  C
1  1  2
2  3  4
3  5  6
</pre>


```python
# 행 축으로 결합하면서 중복 여부를 확인한다. 
# 인덱스에 중복 값이 있으면 오류가 난다.
print(pandas.concat([df1, df2], verify_integrity=True))
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-51-684881e84e99> in <module>
          1 # 행 축으로 결합하면서 중복 여부를 확인한다.
          2 # 인덱스에 중복 값이 있으면 오류가 난다.
    ----> 3 print(pandas.concat([df1, df2], verify_integrity=True))
    

    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/concat.py in concat(objs, axis, join, ignore_index, keys, levels, names, verify_integrity, sort, copy)
        269     ValueError: Indexes have overlapping values: ['a']
        270     """
    --> 271     op = _Concatenator(
        272         objs,
        273         axis=axis,


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/concat.py in __init__(self, objs, axis, join, keys, levels, names, ignore_index, verify_integrity, copy, sort)
        450         self.copy = copy
        451 
    --> 452         self.new_axes = self._get_new_axes()
        453 
        454     def get_result(self):


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/concat.py in _get_new_axes(self)
        513     def _get_new_axes(self) -> List[Index]:
        514         ndim = self._get_result_dim()
    --> 515         return [
        516             self._get_concat_axis() if i == self.axis else self._get_comb_axis(i)
        517             for i in range(ndim)


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/concat.py in <listcomp>(.0)
        514         ndim = self._get_result_dim()
        515         return [
    --> 516             self._get_concat_axis() if i == self.axis else self._get_comb_axis(i)
        517             for i in range(ndim)
        518         ]


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/concat.py in _get_concat_axis(self)
        570             )
        571 
    --> 572         self._maybe_check_integrity(concat_axis)
        573 
        574         return concat_axis


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/concat.py in _maybe_check_integrity(self, concat_index)
        578             if not concat_index.is_unique:
        579                 overlap = concat_index[concat_index.duplicated()].unique()
    --> 580                 raise ValueError(
        581                     "Indexes have overlapping values: "
        582                     "{overlap!s}".format(overlap=overlap)


    ValueError: Indexes have overlapping values: Int64Index([1, 2], dtype='int64')



```python
# 열 축으로 결합하면서 중복 여부를 확인한다. 
# 열 이름에 중복이 있으면 오류가 난다.
print(pandas.concat([df1, df2], axis=1, verify_integrity=True))
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-52-6a7312a23c47> in <module>
          1 # 열 축으로 결합하면서 중복 여부를 확인한다.
          2 # 열 이름에 중복이 있으면 오류가 난다.
    ----> 3 print(pandas.concat([df1, df2], axis=1, verify_integrity=True))
    

    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/concat.py in concat(objs, axis, join, ignore_index, keys, levels, names, verify_integrity, sort, copy)
        269     ValueError: Indexes have overlapping values: ['a']
        270     """
    --> 271     op = _Concatenator(
        272         objs,
        273         axis=axis,


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/concat.py in __init__(self, objs, axis, join, keys, levels, names, ignore_index, verify_integrity, copy, sort)
        450         self.copy = copy
        451 
    --> 452         self.new_axes = self._get_new_axes()
        453 
        454     def get_result(self):


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/concat.py in _get_new_axes(self)
        513     def _get_new_axes(self) -> List[Index]:
        514         ndim = self._get_result_dim()
    --> 515         return [
        516             self._get_concat_axis() if i == self.axis else self._get_comb_axis(i)
        517             for i in range(ndim)


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/concat.py in <listcomp>(.0)
        514         ndim = self._get_result_dim()
        515         return [
    --> 516             self._get_concat_axis() if i == self.axis else self._get_comb_axis(i)
        517             for i in range(ndim)
        518         ]


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/concat.py in _get_concat_axis(self)
        570             )
        571 
    --> 572         self._maybe_check_integrity(concat_axis)
        573 
        574         return concat_axis


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/concat.py in _maybe_check_integrity(self, concat_index)
        578             if not concat_index.is_unique:
        579                 overlap = concat_index[concat_index.duplicated()].unique()
    --> 580                 raise ValueError(
        581                     "Indexes have overlapping values: "
        582                     "{overlap!s}".format(overlap=overlap)


    ValueError: Indexes have overlapping values: Index(['B'], dtype='object')


# **merge()** 메소드

데이터프레임을 병합한다.
- 고성능 인메모리(in-memory) 조인(join) 연산을 수행한다.
- 관계형 데이터베이스의 조인(join) 연산과 유사하다. 
    + 따라서 축과 축 이름을 기준으로 데이터를 결합하는 **concat** 메소드와 달리 **셀의 데이터 값을 기준으로 결합**하기 때문에 데이터베이스의 SQL과 유사하게 작동한다.
- 디폴트는 **inner join**이다.
- 데이터프레임의 **merge() 메소드**도 같은 방식으로 작동한다.
    + [pandas.DataFrame.merge](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.merge.html#pandas.DataFrame.merge)

[pandas.merge](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.merge.html#pandas.merge)
- Merge DataFrame or named Series objects with a database-style join.
- The join is done on columns or indexes. If joining columns on columns, the DataFrame indexes will be ignored. Otherwise if joining indexes on indexes or indexes on a column or columns, the index will be passed on.
- pandas.**merge**(*left, right, how='inner', on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=False, suffixes=('_x', '_y'), copy=True, indicator=False, validate=None*)
    - ***how*** : {*'left'*, *'right'*, *'outer'*, *'inner'*}, default *'inner'*
        - Type of merge to be performed.
        - ***left***: use only keys from left frame, similar to a SQL **left outer join**; preserve key order.
        - ***right***: use only keys from right frame, similar to a SQL **right outer join**; preserve key order.
        - ***outer***: use *union* of keys from both frames, similar to a SQL **full outer join**; sort keys lexicographically.
        - ***inner***: use intersection of keys from both frames, similar to a SQL **inner join**; preserve the order of the left keys.
    - ***on*** : *label* or *list*
        - Column or index level names to join on. These must be found in both DataFrames. If on *is None and not merging on indexes then this defaults to the intersection of the columns in both DataFrames.
    - ***left_on*** : *label* or *list*, or *array-like*
        - Column or index level names to join on in the left DataFrame. Can also be an array or list of arrays of the length of the left DataFrame. These arrays are treated as if they are columns.
    - ***right_on*** : *label* or *list*, or *array-like*
        - Column or index level names to join on in the right DataFrame. Can also be an array or list of arrays of the length of the right DataFrame. These arrays are treated as if they are columns.
    - ***left_index*** : *bool*, default False
        - Use the index from the left DataFrame as the join key(s). If it is a MultiIndex, the number of keys in the other DataFrame (either the index or a number of columns) must match the number of levels.
    - ***right_index*** : *bool*, default False
        - Use the index from the right DataFrame as the join key. Same caveats as left_index.
    - ***suffixes*** : *tuple of (str, str)*, default (‘_x’, ‘_y’)
        - Suffix to apply to overlapping column names in the left and right side, respectively. To raise an exception on overlapping columns use (False, False).
    - ***indicator*** : *bool* or *str*, default False
        - If True, adds a column to output DataFrame called “_merge” with information on the source of each row. If string, column with information on source of each row will be added to output DataFrame, and column will be named value of string. Information column is Categorical-type and takes on a value of “left_only” for observations whose merge key only appears in ‘left’ DataFrame, “right_only” for observations whose merge key only appears in ‘right’ DataFrame, and “both” if the observation’s merge key is found in both.
    - ***validate*** : *str*, optional
        - If specified, checks if merge is of specified type.
            - **'one_to_one'** or **'1:1'**: check if merge keys are unique in both left and right datasets.
            - **'one_to_many'** or **'1:m'**: check if merge keys are unique in left dataset.
            - **'many_to_one'** or **'m:1'**: check if merge keys are unique in right dataset.
            - **'many_to_many'** or **'m:m'**: allowed, but does not result in checks.
    - Returns:
        - DataFrame
            - A DataFrame of the two merged objects.

## 인덱스와 열 이름이 모두 같지만 병합 열을 지정하지 않은 경우


```python
df1 = pandas.DataFrame([[1, 2, 3], [4, 5, 6]],
                       index=list('ab'),
                       columns=list('ABC'))

# df1과 중복 값이 없다.
df2 = pandas.DataFrame([[7, 8, 9], [10, 11, 12]], 
                       index=list('ab'),
                       columns=list('ABC'))   

# df2와 한 행 전체의 값이 같다.
df3 = pandas.DataFrame([[10, 11, 12], [13, 14, 15]],
                       index=list('ab'),
                       columns=list('ABC'))   

# df2와 일부 값만 같다.
df4 = pandas.DataFrame([[11, 12, 13], [14, 15, 16]],
                       index=list('ab'),
                       columns=list('ABC'))   
```


```python
print(df1)
```

       A  B  C
    a  1  2  3
    b  4  5  6



```python
print(df2)
```

        A   B   C
    a   7   8   9
    b  10  11  12



```python
print(df3)
```

        A   B   C
    a  10  11  12
    b  13  14  15



```python
print(df4)
```

        A   B   C
    a  11  12  13
    b  14  15  16


### 중복 값이 없는 경우

**=== Inner join =======**

**df1** / **df2**
<pre>
   A  B  C
a  1  2  3
b  4  5  6

    A   B   C
a   7   8   9
b  10  11  12
</pre>


```python
# 중복 값이 없는 df1과 df2를 기본값(inner join)으로 병합한다.
print(pandas.merge(df1, df2))

# pandas.merge(df1, df2, how='inner')와 같다.
```

    Empty DataFrame
    Columns: [A, B, C]
    Index: []



```python
# 중복 값이 없는 df1과 df2를 inner join으로 결합하는 concat 메소드의 경우
print(pandas.concat([df1, df2], join='inner'))
```

        A   B   C
    a   1   2   3
    b   4   5   6
    a   7   8   9
    b  10  11  12


**=== Outer join =======**

**df1** / **df2**
<pre>
   A  B  C
a  1  2  3
b  4  5  6

    A   B   C
a   7   8   9
b  10  11  12
</pre>


```python
# 중복 값이 없는 df1과 df2를 outer join으로 병합한다.
print(pandas.merge(df1, df2, how='outer'))
```

        A   B   C
    0   1   2   3
    1   4   5   6
    2   7   8   9
    3  10  11  12



```python
# 중복 값이 없는 df1과 df2를 outer join으로 결합하는 concat드 메소드의 경우
print(pandas.concat([df1, df2]))

# pandas.concat([df1, df2], join='outer')와 같다.
```

        A   B   C
    a   1   2   3
    b   4   5   6
    a   7   8   9
    b  10  11  12


**=== Left outer join =======**

**df1** / **df2**
<pre>
   A  B  C
a  1  2  3
b  4  5  6

    A   B   C
a   7   8   9
b  10  11  12
</pre>


```python
# 중복 값이 없는 df1과 df2를 left outer join으로 병합한다.
print(pandas.merge(df1, df2, how='left'))
```

       A  B  C
    0  1  2  3
    1  4  5  6



```python
# 중복 값이 없는 df1과 df2를 left outer join으로 병합한다.
# 이 때 병합 정보도 함께 포함해서 보여준다.
print(pandas.merge(df1, df2, how='left', indicator=True))
```

       A  B  C     _merge
    0  1  2  3  left_only
    1  4  5  6  left_only


**=== Right outer join =======**

**df1** / **df2**
<pre>
   A  B  C
a  1  2  3
b  4  5  6

    A   B   C
a   7   8   9
b  10  11  12
</pre>


```python
# 중복 값이 없는 df1과 df2를 right outer join으로 병합한다.
print(pandas.merge(df1, df2, how='right'))
```

        A   B   C
    0   7   8   9
    1  10  11  12



```python
# 중복 값이 없는 df1과 df2를 right outer join으로 병합한다.
# 이 때 병합 정보도 함께 포함해서 보여준다.
print(pandas.merge(df1, df2, how='right', indicator=True))
```

        A   B   C      _merge
    0   7   8   9  right_only
    1  10  11  12  right_only


### 한 행 전체의 값이 같은 경우

**=== Inner join =======**

**df2** / **df3**
<pre>
    A   B   C
a   7   8   9
b  10  11  12

    A   B   C
a  10  11  12
b  13  14  15
</pre>


```python
# 한 행 전체의 값이 같은 df2과 df3를 기본값(inner join)으로 병합한다.
print(pandas.merge(df2, df3))

# pandas.merge(df2, df3, how='inner')와 같다.
```

        A   B   C
    0  10  11  12



```python
# 한 행 전체의 값이 같은 df2과 df3을 inner join으로 결합하는 concat드 메소드의 경우
print(pandas.concat([df2, df3], join='inner'))
```

        A   B   C
    a   7   8   9
    b  10  11  12
    a  10  11  12
    b  13  14  15


**=== Outer join =======**

**df2** / **df3**
<pre>
    A   B   C
a   7   8   9
b  10  11  12

    A   B   C
a  10  11  12
b  13  14  15
</pre>


```python
# 한 행 전체의 값이 같은 df2과 df3를 outer join으로 병합한다.
print(pandas.merge(df2, df3, how='outer'))
```

        A   B   C
    0   7   8   9
    1  10  11  12
    2  13  14  15



```python
# 한 행 전체의 값이 같은 df2과 df3을 outer join으로 결합하는 concat드 메소드의 경우
print(pandas.concat([df2, df3]))

# pandas.concat([df2, df3], join='outer')와 같다.
```

        A   B   C
    a   7   8   9
    b  10  11  12
    a  10  11  12
    b  13  14  15


**=== Left outer join =======**

**df2** / **df3**
<pre>
    A   B   C
a   7   8   9
b  10  11  12

    A   B   C
a  10  11  12
b  13  14  15
</pre>


```python
# 한 행 전체의 값이 같은 df2과 df3를 left outer join으로 병합한다.
# 이 때 병합 정보도 함께 포함해서 보여준다.
print(pandas.merge(df2, df3, how='left', indicator=True))
```

        A   B   C     _merge
    0   7   8   9  left_only
    1  10  11  12       both


**=== Right outer join =======**

**df2** / **df3**
<pre>
    A   B   C
a   7   8   9
b  10  11  12

    A   B   C
a  10  11  12
b  13  14  15
</pre>


```python
# 한 행 전체의 값이 같은 df2과 df3를 right outer join으로 병합한다.
# 이 때 병합 정보도 함께 포함해서 보여준다.
print(pandas.merge(df2, df3, how='right', indicator=True))
```

        A   B   C      _merge
    0  10  11  12        both
    1  13  14  15  right_only


### 일부 값이 같은 경우

**=== Inner join =======**

**df2** / **df4**
<pre>
    A   B   C
a   7   8   9
b  10  11  12

    A   B   C
a  11  12  13
b  14  15  16
</pre>


```python
# 일부 값이 같은 df2과 df4를 기본값(inner join)으로 병합한다.
print(pandas.merge(df2, df4))

# pandas.merge(df2, df4, how='inner')와 같다.
```

    Empty DataFrame
    Columns: [A, B, C]
    Index: []



```python
# 일부 값이 같은 df2와 df4를 inner join으로 결합하는 concat 메소드의 경우
print(pandas.concat([df2, df4], join='inner'))
```

        A   B   C
    a   7   8   9
    b  10  11  12
    a  11  12  13
    b  14  15  16


**=== Full outer join =======**

**df2** / **df4**
<pre>
    A   B   C
a   7   8   9
b  10  11  12

    A   B   C
a  11  12  13
b  14  15  16
</pre>


```python
# 일부 값이 같은 df2과 df4를 outer join으로 병합한다.
print(pandas.merge(df2, df4, how='outer'))
```

        A   B   C
    0   7   8   9
    1  10  11  12
    2  11  12  13
    3  14  15  16



```python
# 일부 값이 같은 df2와 df4를 outer join으로 결합하는 concat 메소드의 경우
print(pandas.concat([df2, df4]))

# pandas.concat([df2, df3], join='outer')와 같다.
```

        A   B   C
    a   7   8   9
    b  10  11  12
    a  11  12  13
    b  14  15  16


**=== Left outer join =======**

**df2** / **df4**
<pre>
    A   B   C
a   7   8   9
b  10  11  12

    A   B   C
a  11  12  13
b  14  15  16
</pre>


```python
# 일부 값이 같은 df2과 df4를 left outer join으로 병합한다.
# 이 때 병합 정보도 함께 포함해서 보여준다.
print(pandas.merge(df2, df4, how='left', indicator=True))
```

        A   B   C     _merge
    0   7   8   9  left_only
    1  10  11  12  left_only


**=== Right outer join =======**

**df2** / **df4**
<pre>
    A   B   C
a   7   8   9
b  10  11  12

    A   B   C
a  11  12  13
b  14  15  16
</pre>


```python
# 일부 값이 같은 df2과 df4를 righ outer join으로 병합한다.
# 이 때 병합 정보도 함께 포함해서 보여준다.
print(pandas.merge(df2, df4, how='right', indicator=True))
```

        A   B   C      _merge
    0  11  12  13  right_only
    1  14  15  16  right_only


## 중복 키와 Cartesian product

키의 조합이 양쪽 데이터프레임에서 두 번 이상 나타나면, 병합하는 데이터프레임은 Cartesian product로 데이터프레임을 병합한다.

**Cartesian product(데카르트 곱)**:

임의의 두 집합 A, B가 있을 경우, A의 원소 a를 첫 번째, B의 원소 b를 두 번째로 하는 모든 가능한 순서가 있는 쌍 (a, b) 집합을 말하며, **A × B**로 표기하며 A cross B라고 읽는다. 

데이터베이스의 경우 이는 주로 두 테이블 간에 정의한 관계가 없을 때 발생한다.


```python
df1 = pandas.DataFrame({'key': ['가', '가', '나', '다'],
                        'data': ['a', 'b', 'x', 'y']})

df2 = pandas.DataFrame({'key': ['가', '가', '가', '라'], 
                        'data': ['c', 'd', 'e', 'z']})
```


```python
print(df1)
```

      key data
    0   가    a
    1   가    b
    2   나    x
    3   다    y



```python
print(df2)
```

      key data
    0   가    c
    1   가    d
    2   가    e
    3   라    z



```python
# 병합하는 열을 'key'로 하여 기본값(inner join)으로 병합한다.
print(pandas.merge(df1, df2, on='key'))
```

      key data_x data_y
    0   가      a      c
    1   가      a      d
    2   가      a      e
    3   가      b      c
    4   가      b      d
    5   가      b      e



```python
# 병합하는 열을 'key'로 하여 outer join으로 병합한다.
print(pandas.merge(df1, df2, how='outer', on='key'))
```

      key data_x data_y
    0   가      a      c
    1   가      a      d
    2   가      a      e
    3   가      b      c
    4   가      b      d
    5   가      b      e
    6   나      x    NaN
    7   다      y    NaN
    8   라    NaN      z


### 병합 열의 이름이 같은 경우와 다른 경우


```python
# --- 키 열의 이름이 같고 일부 열 이름 다르다.
df1 = pandas.DataFrame({'key': list('가나다가라'),
                        'data': list(range(10, 15)),
                        'ldata': list(range(15, 20))})

df2 = pandas.DataFrame({'key': list('나가다마다'), 
                        'data': list(range(20, 25)),
                        'rdata': list(range(25, 30))})

# --- 모든 열의 이름이 다르다.
df3 = pandas.DataFrame({'lkey': list('가나다가라'),
                        'ldata': list(range(15, 20))})

df4 = pandas.DataFrame({'rkey': list('나가다마다'),
                        'rdata': list(range(25, 30))})

# --- 키 열의 이름이 다르고 일부 열 이름도 다르다.
df5 = pandas.DataFrame({'lkey': list('가나다가라'),
                        'data': list(range(10, 15)),
                        'ldata': list(range(15, 20))})

df6 = pandas.DataFrame({'rkey': list('나가다마다'),
                        'data': list(range(20, 25)),
                        'rdata': list(range(25, 30))})
```


```python
print(df1)
```

      key  data  ldata
    0   가    10     15
    1   나    11     16
    2   다    12     17
    3   가    13     18
    4   라    14     19



```python
print(df2)
```

      key  data  rdata
    0   나    20     25
    1   가    21     26
    2   다    22     27
    3   마    23     28
    4   다    24     29



```python
print(df3)
```

      lkey  ldata
    0    가     15
    1    나     16
    2    다     17
    3    가     18
    4    라     19



```python
print(df4)
```

      rkey  rdata
    0    나     25
    1    가     26
    2    다     27
    3    마     28
    4    다     29



```python
print(df5)
```

      lkey  data  ldata
    0    가    10     15
    1    나    11     16
    2    다    12     17
    3    가    13     18
    4    라    14     19



```python
print(df6)
```

      rkey  data  rdata
    0    나    20     25
    1    가    21     26
    2    다    22     27
    3    마    23     28
    4    다    24     29


#### 병합 열을 지정하지 않는 경우

**=== Inner join =======**

**df1** / **df2**
<pre>
  key  data  ldata
0   가    10     15
1   나    11     16
2   다    12     17
3   가    13     18
4   라    14     19

  key  data  rdata
0   나    20     25
1   가    21     26
2   다    22     27
3   마    23     28
4   다    24     29
</pre>


```python
# --- df1과 df2는 키 열의 이름이 같고 일부 열 이름이 다르다.
# 병합하는 열을 지정하지 않고 기본값(inner join)으로 병합한다.
print(pandas.merge(df1, df2))
```

    Empty DataFrame
    Columns: [key, data, ldata, rdata]
    Index: []


**df3** / **df4**
<pre>
  lkey  ldata
0    가     15
1    나     16
2    다     17
3    가     18
4    라     19

  rkey  rdata
0    나     25
1    가     26
2    다     27
3    마     28
4    다     29
</pre>


```python
# --- df3과 df4는 키 열의 이름과 나머지 열 이름 모두 다르다.
# 병합할 열 이름을 지정하지 않고 기본값(inner join)으로 병합한다.
# 따라서 병할할 열이 없어 오류가 난다.
print(pandas.merge(df3, df4))
```


    ---------------------------------------------------------------------------

    MergeError                                Traceback (most recent call last)

    <ipython-input-92-6124b3d19dbd> in <module>
          2 # 병합할 열 이름을 지정하지 않고 기본값(inner join)으로 병합한다.
          3 # 따라서 병할할 열이 없어 오류가 난다.
    ----> 4 print(pandas.merge(df3, df4))
    

    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in merge(left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate)
         71     validate=None,
         72 ) -> "DataFrame":
    ---> 73     op = _MergeOperation(
         74         left,
         75         right,


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in __init__(self, left, right, how, on, left_on, right_on, axis, left_index, right_index, sort, suffixes, copy, indicator, validate)
        618             warnings.warn(msg, UserWarning)
        619 
    --> 620         self._validate_specification()
        621 
        622         # note this function has side effects


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in _validate_specification(self)
       1189                 common_cols = self.left.columns.intersection(self.right.columns)
       1190                 if len(common_cols) == 0:
    -> 1191                     raise MergeError(
       1192                         "No common columns to perform merge on. "
       1193                         "Merge options: left_on={lon}, right_on={ron}, "


    MergeError: No common columns to perform merge on. Merge options: left_on=None, right_on=None, left_index=False, right_index=False


**df5** / **df6**
<pre>
  lkey  data  ldata
0    가    10     15
1    나    11     16
2    다    12     17
3    가    13     18
4    라    14     19

  rkey  data  rdata
0    나    20     25
1    가    21     26
2    다    22     27
3    마    23     28
4    다    24     29
</pre>


```python
# --- df5와 df6은 키 열의 이름이 다르고 일부 열 이름도 다르다.
# 같은 이름의 열이 있지만 병합할 열 이름을 지정하지 않고
# 기본값(inner join)으로 병합한다.
print(pandas.merge(df5, df6))
```

    Empty DataFrame
    Columns: [lkey, data, ldata, rkey, rdata]
    Index: []


**=== Full outer join =======**

**df1** / **df2**
<pre>
  key  data  ldata
0   가    10     15
1   나    11     16
2   다    12     17
3   가    13     18
4   라    14     19

  key  data  rdata
0   나    20     25
1   가    21     26
2   다    22     27
3   마    23     28
4   다    24     29
</pre>


```python
# --- df1과 df2는 키 열의 이름이 같고 일부 열 이름이 다르다.
# 병합하는 열을 지정하지 않고 outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
# [참고] pandas.concat([df1, df2])과 인덱스 값만 다르고 결과는 같다.
print(pandas.merge(df1, df2, how='outer', indicator=True))
```

      key  data  ldata  rdata      _merge
    0   가    10   15.0    NaN   left_only
    1   나    11   16.0    NaN   left_only
    2   다    12   17.0    NaN   left_only
    3   가    13   18.0    NaN   left_only
    4   라    14   19.0    NaN   left_only
    5   나    20    NaN   25.0  right_only
    6   가    21    NaN   26.0  right_only
    7   다    22    NaN   27.0  right_only
    8   마    23    NaN   28.0  right_only
    9   다    24    NaN   29.0  right_only


**df3** / **df4**
<pre>
  lkey  ldata
0    가     15
1    나     16
2    다     17
3    가     18
4    라     19

  rkey  rdata
0    나     25
1    가     26
2    다     27
3    마     28
4    다     29
</pre>


```python
# --- df3과 df4는 키 열의 이름과 나머지 열 이름 모두 다르다.
# 병합하는 열을 지정하지 않고 outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
# 하지만 병합할 열을 지정하지 않아서 오류가 난다.
print(pandas.merge(df3, df4, how='outer', indicator=True))
```


    ---------------------------------------------------------------------------

    MergeError                                Traceback (most recent call last)

    <ipython-input-95-2b7e39e77e25> in <module>
          3 # 이 때 병합 정보를 포함하도록 한다.
          4 # 하지만 병합할 열을 지정하지 않아서 오류가 난다.
    ----> 5 print(pandas.merge(df3, df4, how='outer', indicator=True))
    

    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in merge(left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate)
         71     validate=None,
         72 ) -> "DataFrame":
    ---> 73     op = _MergeOperation(
         74         left,
         75         right,


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in __init__(self, left, right, how, on, left_on, right_on, axis, left_index, right_index, sort, suffixes, copy, indicator, validate)
        618             warnings.warn(msg, UserWarning)
        619 
    --> 620         self._validate_specification()
        621 
        622         # note this function has side effects


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in _validate_specification(self)
       1189                 common_cols = self.left.columns.intersection(self.right.columns)
       1190                 if len(common_cols) == 0:
    -> 1191                     raise MergeError(
       1192                         "No common columns to perform merge on. "
       1193                         "Merge options: left_on={lon}, right_on={ron}, "


    MergeError: No common columns to perform merge on. Merge options: left_on=None, right_on=None, left_index=False, right_index=False


**df5** / **df6**
<pre>
  lkey  data  ldata
0    가    10     15
1    나    11     16
2    다    12     17
3    가    13     18
4    라    14     19

  rkey  data  rdata
0    나    20     25
1    가    21     26
2    다    22     27
3    마    23     28
4    다    24     29
</pre>


```python
# --- df5와 df6은 키 열의 이름이 다르고 일부 열 이름도 다르다.
# 같은 이름의 열이 있지만 병합할 열 이름을 지정하지 않고
# outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
# inner join과의 차이는 무엇인가?
print(pandas.merge(df5, df6, how='outer', indicator=True))
```

      lkey  data  ldata rkey  rdata      _merge
    0    가    10   15.0  NaN    NaN   left_only
    1    나    11   16.0  NaN    NaN   left_only
    2    다    12   17.0  NaN    NaN   left_only
    3    가    13   18.0  NaN    NaN   left_only
    4    라    14   19.0  NaN    NaN   left_only
    5  NaN    20    NaN    나   25.0  right_only
    6  NaN    21    NaN    가   26.0  right_only
    7  NaN    22    NaN    다   27.0  right_only
    8  NaN    23    NaN    마   28.0  right_only
    9  NaN    24    NaN    다   29.0  right_only


**=== Left outer join =======**

**df1** / **df2**
<pre>
  key  data  ldata
0   가    10     15
1   나    11     16
2   다    12     17
3   가    13     18
4   라    14     19

  key  data  rdata
0   나    20     25
1   가    21     26
2   다    22     27
3   마    23     28
4   다    24     29
</pre>


```python
# --- df1과 df2는 키 열의 이름이 같고 일부 열 이름이 다르다.
# 병합하는 열을 지정하지 않고 left outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
print(pandas.merge(df1, df2, how='left', indicator=True))
```

      key  data  ldata  rdata     _merge
    0   가    10     15    NaN  left_only
    1   나    11     16    NaN  left_only
    2   다    12     17    NaN  left_only
    3   가    13     18    NaN  left_only
    4   라    14     19    NaN  left_only


**df3** / **df4**
<pre>
  lkey  ldata
0    가     15
1    나     16
2    다     17
3    가     18
4    라     19

  rkey  rdata
0    나     25
1    가     26
2    다     27
3    마     28
4    다     29
</pre>


```python
# --- df3과 df4는 키 열의 이름과 나머지 열 이름 모두 다르다.
# 병합하는 열을 지정하지 않고 left outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
# 하지만 병합할 열을 지정하지 않아서 오류가 난다.
print(pandas.merge(df3, df4, how='left', indicator=True))
```


    ---------------------------------------------------------------------------

    MergeError                                Traceback (most recent call last)

    <ipython-input-98-6ca5e66c4932> in <module>
          3 # 이 때 병합 정보를 포함하도록 한다.
          4 # 하지만 병합할 열을 지정하지 않아서 오류가 난다.
    ----> 5 print(pandas.merge(df3, df4, how='left', indicator=True))
    

    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in merge(left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate)
         71     validate=None,
         72 ) -> "DataFrame":
    ---> 73     op = _MergeOperation(
         74         left,
         75         right,


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in __init__(self, left, right, how, on, left_on, right_on, axis, left_index, right_index, sort, suffixes, copy, indicator, validate)
        618             warnings.warn(msg, UserWarning)
        619 
    --> 620         self._validate_specification()
        621 
        622         # note this function has side effects


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in _validate_specification(self)
       1189                 common_cols = self.left.columns.intersection(self.right.columns)
       1190                 if len(common_cols) == 0:
    -> 1191                     raise MergeError(
       1192                         "No common columns to perform merge on. "
       1193                         "Merge options: left_on={lon}, right_on={ron}, "


    MergeError: No common columns to perform merge on. Merge options: left_on=None, right_on=None, left_index=False, right_index=False


**df5** / **df6**
<pre>
  lkey  data  ldata
0    가    10     15
1    나    11     16
2    다    12     17
3    가    13     18
4    라    14     19

  rkey  data  rdata
0    나    20     25
1    가    21     26
2    다    22     27
3    마    23     28
4    다    24     29
</pre>


```python
# --- df5와 df6은 키 열의 이름이 다르고 일부 열 이름도 다르다.
# 같은 이름의 열이 있지만 병합할 열 이름을 지정하지 않고
# left outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
# inner join / full outer join과의 차이는 무엇인가?
print(pandas.merge(df5, df6, how='left', indicator=True))
```

      lkey  data  ldata rkey  rdata     _merge
    0    가    10     15  NaN    NaN  left_only
    1    나    11     16  NaN    NaN  left_only
    2    다    12     17  NaN    NaN  left_only
    3    가    13     18  NaN    NaN  left_only
    4    라    14     19  NaN    NaN  left_only


**=== Right outer join =======**

**df1** / **df2**
<pre>
  key  data  ldata
0   가    10     15
1   나    11     16
2   다    12     17
3   가    13     18
4   라    14     19

  key  data  rdata
0   나    20     25
1   가    21     26
2   다    22     27
3   마    23     28
4   다    24     29
</pre>


```python
# --- df1과 df2는 키 열의 이름이 같고 일부 열 이름이 다르다.
# 병합하는 열을 지정하지 않고 right outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
print(pandas.merge(df1, df2, how='right', indicator=True))
```

      key  data  ldata  rdata      _merge
    0   나    20    NaN     25  right_only
    1   가    21    NaN     26  right_only
    2   다    22    NaN     27  right_only
    3   마    23    NaN     28  right_only
    4   다    24    NaN     29  right_only


**df3** / **df4**
<pre>
  lkey  ldata
0    가     15
1    나     16
2    다     17
3    가     18
4    라     19

  rkey  rdata
0    나     25
1    가     26
2    다     27
3    마     28
4    다     29
</pre>


```python
# --- df3과 df4는 키 열의 이름과 나머지 열 이름 모두 다르다.
# 병합하는 열을 지정하지 않고 left outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
# 하지만 병합할 열을 지정하지 않아서 오류가 난다.
print(pandas.merge(df3, df4, how='right', indicator=True))
```


    ---------------------------------------------------------------------------

    MergeError                                Traceback (most recent call last)

    <ipython-input-101-330725aba2f7> in <module>
          3 # 이 때 병합 정보를 포함하도록 한다.
          4 # 하지만 병합할 열을 지정하지 않아서 오류가 난다.
    ----> 5 print(pandas.merge(df3, df4, how='right', indicator=True))
    

    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in merge(left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate)
         71     validate=None,
         72 ) -> "DataFrame":
    ---> 73     op = _MergeOperation(
         74         left,
         75         right,


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in __init__(self, left, right, how, on, left_on, right_on, axis, left_index, right_index, sort, suffixes, copy, indicator, validate)
        618             warnings.warn(msg, UserWarning)
        619 
    --> 620         self._validate_specification()
        621 
        622         # note this function has side effects


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in _validate_specification(self)
       1189                 common_cols = self.left.columns.intersection(self.right.columns)
       1190                 if len(common_cols) == 0:
    -> 1191                     raise MergeError(
       1192                         "No common columns to perform merge on. "
       1193                         "Merge options: left_on={lon}, right_on={ron}, "


    MergeError: No common columns to perform merge on. Merge options: left_on=None, right_on=None, left_index=False, right_index=False


**df5** / **df6**
<pre>
  lkey  data  ldata
0    가    10     15
1    나    11     16
2    다    12     17
3    가    13     18
4    라    14     19

  rkey  data  rdata
0    나    20     25
1    가    21     26
2    다    22     27
3    마    23     28
4    다    24     29
</pre>


```python
# --- df5와 df6은 키 열의 이름이 다르고 일부 열 이름도 다르다.
# 같은 이름의 열이 있지만 병합할 열 이름을 지정하지 않고
# left outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
# inner join / full outer join과의 차이는 무엇인가?
print(pandas.merge(df5, df6, how='right', indicator=True))
```

      lkey  data  ldata rkey  rdata      _merge
    0  NaN    20    NaN    나     25  right_only
    1  NaN    21    NaN    가     26  right_only
    2  NaN    22    NaN    다     27  right_only
    3  NaN    23    NaN    마     28  right_only
    4  NaN    24    NaN    다     29  right_only


#### 병합 열을 지정하는 경우

**=== Inner join =======**

**df1** / **df2**
<pre>
  key  data  ldata
0   가    10     15
1   나    11     16
2   다    12     17
3   가    13     18
4   라    14     19

  key  data  rdata
0   나    20     25
1   가    21     26
2   다    22     27
3   마    23     28
4   다    24     29
</pre>


```python
# --- df1과 df2는 키 열의 이름이 같고 일부 열 이름이 다르다.
# 병합하는 열을 'key'로 지정하고 기본값(inner join)으로 병합한다.
print(pandas.merge(df1, df2, on='key'))
```

      key  data_x  ldata  data_y  rdata
    0   가      10     15      21     26
    1   가      13     18      21     26
    2   나      11     16      20     25
    3   다      12     17      22     27
    4   다      12     17      24     29


**df3** / **df4**
<pre>
  lkey  ldata
0    가     15
1    나     16
2    다     17
3    가     18
4    라     19

  rkey  rdata
0    나     25
1    가     26
2    다     27
3    마     28
4    다     29
</pre>


```python
# --- df3과 df4는 키 열의 이름과 나머지 열 이름 모두 다르다.
# 병합하는 열을 df3은 'lkey'로 df4는 'rkey'로 지정하고 
# 기본값(inner join)으로 병합한다.
print(pandas.merge(df3, df4, left_on='lkey', right_on='rkey'))
```

      lkey  ldata rkey  rdata
    0    가     15    가     26
    1    가     18    가     26
    2    나     16    나     25
    3    다     17    다     27
    4    다     17    다     29


**df5** / **df6**
<pre>
  lkey  data  ldata
0    가    10     15
1    나    11     16
2    다    12     17
3    가    13     18
4    라    14     19

  rkey  data  rdata
0    나    20     25
1    가    21     26
2    다    22     27
3    마    23     28
4    다    24     29
</pre>


```python
# --- df5와 df6은 키 열의 이름이 다르고 일부 열 이름도 다르다.
# 같은 이름의 열이 있지만 병합할 열의 이름이 달라 
# 병합하는 열을 df5는 'lkey'로 df6은 'rkey'로 지정하고 
# 기본값(inner join)으로 병합한다.
print(pandas.merge(df5, df6, left_on='lkey', right_on='rkey'))
```

      lkey  data_x  ldata rkey  data_y  rdata
    0    가      10     15    가      21     26
    1    가      13     18    가      21     26
    2    나      11     16    나      20     25
    3    다      12     17    다      22     27
    4    다      12     17    다      24     29


**매개변수 *indicator* / *suffixes* 사용**

**df1** / **df2**
<pre>
  key  data  ldata
0   가    10     15
1   나    11     16
2   다    12     17
3   가    13     18
4   라    14     19

  key  data  rdata
0   나    20     25
1   가    21     26
2   다    22     27
3   마    23     28
4   다    24     29
</pre>


```python
# --- df1과 df2는 키 열의 이름이 같고 일부 열 이름이 다르다.
# 병합하는 열을 'key'로 지정하고 기본값(inner join)으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
print(pandas.merge(df1, df2, on='key', indicator=True))
```

      key  data_x  ldata  data_y  rdata _merge
    0   가      10     15      21     26   both
    1   가      13     18      21     26   both
    2   나      11     16      20     25   both
    3   다      12     17      22     27   both
    4   다      12     17      24     29   both


**df1** / **df2**
<pre>
  key  data  ldata
0   가    10     15
1   나    11     16
2   다    12     17
3   가    13     18
4   라    14     19

  key  data  rdata
0   나    20     25
1   가    21     26
2   다    22     27
3   마    23     28
4   다    24     29
</pre>


```python
# --- df1과 df2는 키 열의 이름이 같고 일부 열 이름이 다르다.
# 병합하는 열을 'key'로 지정하고 기본값(inner join)으로 병합한다.
# 이 때 병합하는 열 이외 같은 이름을 가진 열을 구분하기 위해 
# 접미어를 지정하고 병합 정보를 포함하도록 한다.
print(pandas.merge(df1, df2, on='key', 
                   suffixes=['_left', '_right'],
                   indicator=True))
```

      key  data_left  ldata  data_right  rdata _merge
    0   가         10     15          21     26   both
    1   가         13     18          21     26   both
    2   나         11     16          20     25   both
    3   다         12     17          22     27   both
    4   다         12     17          24     29   both


**df3** / **df4**
<pre>
  lkey  ldata
0    가     15
1    나     16
2    다     17
3    가     18
4    라     19

  rkey  rdata
0    나     25
1    가     26
2    다     27
3    마     28
4    다     29
</pre>


```python
# --- df3과 df4는 키 열의 이름과 나머지 열 이름 모두 다르다.
# 병합하는 열을 df3은 'lkey'로 df4는 'rkey'로 지정하고 
# 기본값(inner join)으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
print(pandas.merge(df3, df4, 
                   left_on='lkey', right_on='rkey', 
                   indicator=True))
```

      lkey  ldata rkey  rdata _merge
    0    가     15    가     26   both
    1    가     18    가     26   both
    2    나     16    나     25   both
    3    다     17    다     27   both
    4    다     17    다     29   both


**df5** / **df6**
<pre>
  lkey  data  ldata
0    가    10     15
1    나    11     16
2    다    12     17
3    가    13     18
4    라    14     19

  rkey  data  rdata
0    나    20     25
1    가    21     26
2    다    22     27
3    마    23     28
4    다    24     29
</pre>


```python
# --- df5와 df6은 키 열의 이름이 다르고 일부 열 이름도 다르다.
# 같은 이름의 열이 있지만 병합할 열의 이름이 달라 
# 병합하는 열을 df5는 'lkey'로 df6은 'rkey'로 지정하고 
# 기본값(inner join)으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
print(pandas.merge(df5, df6, 
                   left_on='lkey', right_on='rkey', 
                    indicator=True))
```

      lkey  data_x  ldata rkey  data_y  rdata _merge
    0    가      10     15    가      21     26   both
    1    가      13     18    가      21     26   both
    2    나      11     16    나      20     25   both
    3    다      12     17    다      22     27   both
    4    다      12     17    다      24     29   both


**=== Full outer join =======**

**df1** / **df2**
<pre>
  key  data  ldata
0   가    10     15
1   나    11     16
2   다    12     17
3   가    13     18
4   라    14     19

  key  data  rdata
0   나    20     25
1   가    21     26
2   다    22     27
3   마    23     28
4   다    24     29
</pre>


```python
# --- df1과 df2는 키 열의 이름이 같고 일부 열 이름이 다르다.
# 병합하는 열을 'key'로 지정하고 outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
print(pandas.merge(df1, df2, 
                   how='outer', on='key', 
                   indicator=True))
```

      key  data_x  ldata  data_y  rdata      _merge
    0   가    10.0   15.0    21.0   26.0        both
    1   가    13.0   18.0    21.0   26.0        both
    2   나    11.0   16.0    20.0   25.0        both
    3   다    12.0   17.0    22.0   27.0        both
    4   다    12.0   17.0    24.0   29.0        both
    5   라    14.0   19.0     NaN    NaN   left_only
    6   마     NaN    NaN    23.0   28.0  right_only



```python
# --- df1과 df2는 키 열의 이름이 같고 일부 열 이름이 다르다.
# 병합하는 열을 'key'로 지정하고 outer join으로 병합한다.
# 이 때 병합하는 열 이외 같은 이름을 가진 열을 구분하기 위해 
# 접미어를 지정하고 병합 정보를 포함하도록 한다.
print(pandas.merge(df1, df2, how='outer', on='key', 
                   suffixes=['_left', '_right'], 
                   indicator=True))
```

      key  data_left  ldata  data_right  rdata      _merge
    0   가       10.0   15.0        21.0   26.0        both
    1   가       13.0   18.0        21.0   26.0        both
    2   나       11.0   16.0        20.0   25.0        both
    3   다       12.0   17.0        22.0   27.0        both
    4   다       12.0   17.0        24.0   29.0        both
    5   라       14.0   19.0         NaN    NaN   left_only
    6   마        NaN    NaN        23.0   28.0  right_only


**df3** / **df4**
<pre>
  lkey  ldata
0    가     15
1    나     16
2    다     17
3    가     18
4    라     19

  rkey  rdata
0    나     25
1    가     26
2    다     27
3    마     28
4    다     29
</pre>


```python
# --- df3과 df4는 키 열의 이름과 나머지 열 이름 모두 다르다.
# 병합하는 열을 df3은 'lkey'로 df4는 'rkey'로 지정하고 
# outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
print(pandas.merge(df3, df4, how='outer', 
                   left_on='lkey', right_on='rkey',
                    indicator=True))
```

      lkey  ldata rkey  rdata      _merge
    0    가   15.0    가   26.0        both
    1    가   18.0    가   26.0        both
    2    나   16.0    나   25.0        both
    3    다   17.0    다   27.0        both
    4    다   17.0    다   29.0        both
    5    라   19.0  NaN    NaN   left_only
    6  NaN    NaN    마   28.0  right_only


**df5** / **df6**
<pre>
  lkey  data  ldata
0    가    10     15
1    나    11     16
2    다    12     17
3    가    13     18
4    라    14     19

  rkey  data  rdata
0    나    20     25
1    가    21     26
2    다    22     27
3    마    23     28
4    다    24     29
</pre>


```python
# --- df5와 df6은 키 열의 이름이 다르고 일부 열 이름도 다르다.
# 같은 이름의 열이 있지만 병합할 열의 이름이 달라 
# 병합하는 열을 df5는 'lkey'로 df6은 'rkey'로 지정하고 
# outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
print(pandas.merge(df5, df6, how='outer', 
                   left_on='lkey', right_on='rkey',
                   indicator=True))
```

      lkey  data_x  ldata rkey  data_y  rdata      _merge
    0    가    10.0   15.0    가    21.0   26.0        both
    1    가    13.0   18.0    가    21.0   26.0        both
    2    나    11.0   16.0    나    20.0   25.0        both
    3    다    12.0   17.0    다    22.0   27.0        both
    4    다    12.0   17.0    다    24.0   29.0        both
    5    라    14.0   19.0  NaN     NaN    NaN   left_only
    6  NaN     NaN    NaN    마    23.0   28.0  right_only


**=== Left outer join =======**

**df1** / **df2**
<pre>
  key  data  ldata
0   가    10     15
1   나    11     16
2   다    12     17
3   가    13     18
4   라    14     19

  key  data  rdata
0   나    20     25
1   가    21     26
2   다    22     27
3   마    23     28
4   다    24     29
</pre>


```python
# --- df1과 df2는 키 열의 이름이 같고 일부 열 이름이 다르다.
# 병합하는 열을 'key'로 지정하고 left outer join으로 병합한다.
# 이 때 병합하는 열 이외 같은 이름을 가진 열을 구분하기 위해 
# 접미어를 지정하고 병합 정보를 포함하도록 한다.
print(pandas.merge(df1, df2, how='left', on='key', 
                   suffixes=['_left', '_right'],
                   indicator=True))
```

      key  data_left  ldata  data_right  rdata     _merge
    0   가         10     15        21.0   26.0       both
    1   나         11     16        20.0   25.0       both
    2   다         12     17        22.0   27.0       both
    3   다         12     17        24.0   29.0       both
    4   가         13     18        21.0   26.0       both
    5   라         14     19         NaN    NaN  left_only


**df3** / **df4**
<pre>
  lkey  ldata
0    가     15
1    나     16
2    다     17
3    가     18
4    라     19

  rkey  rdata
0    나     25
1    가     26
2    다     27
3    마     28
4    다     29
</pre>


```python
# --- df3과 df4는 키 열의 이름과 나머지 열 이름 모두 다르다.
# 병합하는 열을 df3은 'lkey'로 df4는 'rkey'로 지정하고 
# left outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
# 모든 이름이 달라서 접미어를 지정할 필요가 없다.
print(pandas.merge(df3, df4, how='left', 
                   left_on='lkey', right_on='rkey',
                   indicator=True))
```

      lkey  ldata rkey  rdata     _merge
    0    가     15    가   26.0       both
    1    나     16    나   25.0       both
    2    다     17    다   27.0       both
    3    다     17    다   29.0       both
    4    가     18    가   26.0       both
    5    라     19  NaN    NaN  left_only


**df5** / **df6**
<pre>
  lkey  data  ldata
0    가    10     15
1    나    11     16
2    다    12     17
3    가    13     18
4    라    14     19

  rkey  data  rdata
0    나    20     25
1    가    21     26
2    다    22     27
3    마    23     28
4    다    24     29
</pre>


```python
# --- df5와 df6은 키 열의 이름이 다르고 일부 열 이름도 다르다.
# 같은 이름의 열이 있지만 병합할 열의 이름이 달라 
# 병합하는 열을 df5는 'lkey'로 df6은 'rkey'로 지정하고 
# left outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
print(pandas.merge(df5, df6, how='left', 
                   left_on='lkey', right_on='rkey',
                   indicator=True))
```

      lkey  data_x  ldata rkey  data_y  rdata     _merge
    0    가      10     15    가    21.0   26.0       both
    1    나      11     16    나    20.0   25.0       both
    2    다      12     17    다    22.0   27.0       both
    3    다      12     17    다    24.0   29.0       both
    4    가      13     18    가    21.0   26.0       both
    5    라      14     19  NaN     NaN    NaN  left_only


**=== Right outer join =======**

**df1** / **df2**
<pre>
  key  data  ldata
0   가    10     15
1   나    11     16
2   다    12     17
3   가    13     18
4   라    14     19

  key  data  rdata
0   나    20     25
1   가    21     26
2   다    22     27
3   마    23     28
4   다    24     29
</pre>


```python
# --- df1과 df2는 키 열의 이름이 같고 일부 열 이름이 다르다.
# 병합하는 열을 'key'로 지정하고 right outer join으로 병합한다.
# 이 때 병합하는 열 이외 같은 이름을 가진 열을 구분하기 위해 
# 접미어를 지정하고 병합 정보를 포함하도록 한다.
print(pandas.merge(df1, df2, how='right', on='key', 
                   suffixes=['_left', '_right'],
                   indicator=True))
```

      key  data_left  ldata  data_right  rdata      _merge
    0   가       10.0   15.0          21     26        both
    1   가       13.0   18.0          21     26        both
    2   나       11.0   16.0          20     25        both
    3   다       12.0   17.0          22     27        both
    4   다       12.0   17.0          24     29        both
    5   마        NaN    NaN          23     28  right_only


**df3** / **df4**
<pre>
  lkey  ldata
0    가     15
1    나     16
2    다     17
3    가     18
4    라     19

  rkey  rdata
0    나     25
1    가     26
2    다     27
3    마     28
4    다     29
</pre>


```python
# --- df3과 df4는 키 열의 이름과 나머지 열 이름 모두 다르다.
# 병합하는 열을 df3은 'lkey'로 df4는 'rkey'로 지정하고 
# left outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
# 모든 이름이 달라서 접미어를 지정할 필요가 없다.
print(pandas.merge(df3, df4, how='right', 
                   left_on='lkey', right_on='rkey',
                   indicator=True))
```

      lkey  ldata rkey  rdata      _merge
    0    가   15.0    가     26        both
    1    가   18.0    가     26        both
    2    나   16.0    나     25        both
    3    다   17.0    다     27        both
    4    다   17.0    다     29        both
    5  NaN    NaN    마     28  right_only


**df5** / **df6**
<pre>
  lkey  data  ldata
0    가    10     15
1    나    11     16
2    다    12     17
3    가    13     18
4    라    14     19

  rkey  data  rdata
0    나    20     25
1    가    21     26
2    다    22     27
3    마    23     28
4    다    24     29
</pre>


```python
# --- df5와 df6은 키 열의 이름이 다르고 일부 열 이름도 다르다.
# 같은 이름의 열이 있지만 병합할 열의 이름이 달라 
# 병합하는 열을 df5는 'lkey'로 df6은 'rkey'로 지정하고 
# left outer join으로 병합한다.
# 이 때 병합 정보를 포함하도록 한다.
print(pandas.merge(df5, df6, how='right', 
                   left_on='lkey', right_on='rkey',
                   indicator=True))
```

      lkey  data_x  ldata rkey  data_y  rdata      _merge
    0    가    10.0   15.0    가      21     26        both
    1    가    13.0   18.0    가      21     26        both
    2    나    11.0   16.0    나      20     25        both
    3    다    12.0   17.0    다      22     27        both
    4    다    12.0   17.0    다      24     29        both
    5  NaN     NaN    NaN    마      23     28  right_only


## Cardinality

Cardinality란 병합하는 두 쌍의 농도 또는 크기를 말하며 다음 중 하나로 표현한다.

- 1:1(일대일)
- 1:m(일대다)
- m:1(다대일)
- m:n(다대다)


```python
df1 = pandas.DataFrame({'key': ['가', '나', '다'], 
                        'data': ['a', 'b', 'x']})

df2 = pandas.DataFrame({'key': ['가', '나', '가', '라'], 
                        'data': ['c', 'd', 'e', 'y']})
```


```python
print(df1)
```

      key data
    0   가    a
    1   나    b
    2   다    x



```python
print(df2)
```

      key data
    0   가    c
    1   나    d
    2   가    e
    3   라    y


### 일대일

**df1** / **df2**
<pre>
  key data
0   가    a
1   나    b
2   다    x

  key data
0   가    c
1   나    d
2   가    e
3   라    y
</pre>


```python
# df1과 df2의 병합 열을 'key'로 지정하고 inner join을 할 때 양쪽 키에 중복이 있는지 확인한다.
# 'one_to_one'으로 양쪽 키 모두 중복이 없어야 하는데 
# 오른쪽 키에 중복이 있어 오류가 난다.
print(pandas.merge(df1, df2, on='key', validate='1:1'))
```


    ---------------------------------------------------------------------------

    MergeError                                Traceback (most recent call last)

    <ipython-input-123-d43009baf79a> in <module>
          2 # 'one_to_one'으로 양쪽 키 모두 중복이 없어야 하는데
          3 # 오른쪽 키에 중복이 있어 오류가 난다.
    ----> 4 print(pandas.merge(df1, df2, on='key', validate='1:1'))
    

    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in merge(left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate)
         71     validate=None,
         72 ) -> "DataFrame":
    ---> 73     op = _MergeOperation(
         74         left,
         75         right,


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in __init__(self, left, right, how, on, left_on, right_on, axis, left_index, right_index, sort, suffixes, copy, indicator, validate)
        635         # are in fact unique.
        636         if validate is not None:
    --> 637             self._validate(validate)
        638 
        639     def get_result(self):


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in _validate(self, validate)
       1256                 )
       1257             elif not right_unique:
    -> 1258                 raise MergeError(
       1259                     "Merge keys are not unique in right dataset; "
       1260                     "not a one-to-one merge"


    MergeError: Merge keys are not unique in right dataset; not a one-to-one merge


**df1** / **df2**
<pre>
  key data
0   가    a
1   나    b
2   다    x

  key data
0   가    c
1   나    d
2   가    e
3   라    y
</pre>


```python
# df1과 df2의 병합 열을 'key'로 지정하고 outer join을 할 때 양쪽 키에 중복이 있는지 확인한다.
# 'one_to_one'으로 양쪽 키 모두 중복이 없어야 하는데 
# 오른쪽 키에 중복이 있어 오류가 난다.
print(pandas.merge(df1, df2, how='outer', on='key', validate='1:1'))
```


    ---------------------------------------------------------------------------

    MergeError                                Traceback (most recent call last)

    <ipython-input-124-bc10c92dc61f> in <module>
          2 # 'one_to_one'으로 양쪽 키 모두 중복이 없어야 하는데
          3 # 오른쪽 키에 중복이 있어 오류가 난다.
    ----> 4 print(pandas.merge(df1, df2, how='outer', on='key', validate='1:1'))
    

    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in merge(left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate)
         71     validate=None,
         72 ) -> "DataFrame":
    ---> 73     op = _MergeOperation(
         74         left,
         75         right,


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in __init__(self, left, right, how, on, left_on, right_on, axis, left_index, right_index, sort, suffixes, copy, indicator, validate)
        635         # are in fact unique.
        636         if validate is not None:
    --> 637             self._validate(validate)
        638 
        639     def get_result(self):


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in _validate(self, validate)
       1256                 )
       1257             elif not right_unique:
    -> 1258                 raise MergeError(
       1259                     "Merge keys are not unique in right dataset; "
       1260                     "not a one-to-one merge"


    MergeError: Merge keys are not unique in right dataset; not a one-to-one merge


### 일대다

**df1** / **df2**
<pre>
  key data
0   가    a
1   나    b
2   다    x

  key data
0   가    c
1   나    d
2   가    e
3   라    y
</pre>


```python
# df1과 df2의 병합 열을 'key'로 지정하고 inner join을 할 때 왼쪽 키에 중복이 있는지 확인한다.
# 'one_to_many'로 왼쪽 키에 중복이 있는지 확인한다.
print(pandas.merge(df1, df2, on='key', validate='1:m'))
```

      key data_x data_y
    0   가      a      c
    1   가      a      e
    2   나      b      d


**df1** / **df2**
<pre>
  key data
0   가    a
1   나    b
2   다    x

  key data
0   가    c
1   나    d
2   가    e
3   라    y
</pre>


```python
# df1과 df2의 병합 열을 'key'로 지정하고 outer join을 할 때 왼쪽 키에 중복이 있는지 확인한다.
# 'one_to_many'로 왼쪽 키에 중복이 있는지 확인한다.
print(pandas.merge(df1, df2, how='outer', on='key', validate='1:m'))
```

      key data_x data_y
    0   가      a      c
    1   가      a      e
    2   나      b      d
    3   다      x    NaN
    4   라    NaN      y


### 다대일

**df1** / **df2**
<pre>
  key data
0   가    a
1   나    b
2   다    x

  key data
0   가    c
1   나    d
2   가    e
3   라    y
</pre>


```python
# df1과 df2의 병합 열을 'key'로 지정하고 inner join을 할 때 오른쪽 키에 중복이 있는지 확인한다.
# 'many_to_one'으로 오른쪽 키에 중복이 있는지 확인하는데 
# 중복이 있어 오류가 난다.
print(pandas.merge(df1, df2, on='key', validate='m:1'))
```


    ---------------------------------------------------------------------------

    MergeError                                Traceback (most recent call last)

    <ipython-input-127-6992770a0bb9> in <module>
          2 # 'many_to_one'으로 오른쪽 키에 중복이 있는지 확인하는데
          3 # 중복이 있어 오류가 난다.
    ----> 4 print(pandas.merge(df1, df2, on='key', validate='m:1'))
    

    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in merge(left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate)
         71     validate=None,
         72 ) -> "DataFrame":
    ---> 73     op = _MergeOperation(
         74         left,
         75         right,


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in __init__(self, left, right, how, on, left_on, right_on, axis, left_index, right_index, sort, suffixes, copy, indicator, validate)
        635         # are in fact unique.
        636         if validate is not None:
    --> 637             self._validate(validate)
        638 
        639     def get_result(self):


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in _validate(self, validate)
       1270         elif validate in ["many_to_one", "m:1"]:
       1271             if not right_unique:
    -> 1272                 raise MergeError(
       1273                     "Merge keys are not unique in right dataset; "
       1274                     "not a many-to-one merge"


    MergeError: Merge keys are not unique in right dataset; not a many-to-one merge



```python
# df1과 df2의 병합 열을 'key'로 지정하고 outer join을 할 때 오른쪽 키에 중복이 있는지 확인한다.
# 'many_to_one'으로 오른쪽 키에 중복이 있는지 확인하는데 
# 중복이 있어 오류가 난다.
print(pandas.merge(df1, df2, how='outer', on='key', validate='m:1'))
```


    ---------------------------------------------------------------------------

    MergeError                                Traceback (most recent call last)

    <ipython-input-128-56eed92f037c> in <module>
          2 # 'many_to_one'으로 오른쪽 키에 중복이 있는지 확인하는데
          3 # 중복이 있어 오류가 난다.
    ----> 4 print(pandas.merge(df1, df2, how='outer', on='key', validate='m:1'))
    

    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in merge(left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate)
         71     validate=None,
         72 ) -> "DataFrame":
    ---> 73     op = _MergeOperation(
         74         left,
         75         right,


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in __init__(self, left, right, how, on, left_on, right_on, axis, left_index, right_index, sort, suffixes, copy, indicator, validate)
        635         # are in fact unique.
        636         if validate is not None:
    --> 637             self._validate(validate)
        638 
        639     def get_result(self):


    ~/Dropbox/_data/venv/3.8ds/lib/python3.8/site-packages/pandas/core/reshape/merge.py in _validate(self, validate)
       1270         elif validate in ["many_to_one", "m:1"]:
       1271             if not right_unique:
    -> 1272                 raise MergeError(
       1273                     "Merge keys are not unique in right dataset; "
       1274                     "not a many-to-one merge"


    MergeError: Merge keys are not unique in right dataset; not a many-to-one merge


### 다대다

**df1** / **df2**
<pre>
  key data
0   가    a
1   나    b
2   다    x

  key data
0   가    c
1   나    d
2   가    e
3   라    y
</pre>


```python
# df1과 df2의 병합 열을 'key'로 지정하고 inner join을 할 때 양쪽 키에 중복을 허용한다.
# 'many_to_many'로 양쪽 키 모두 중복이 있어도 된다.
print(pandas.merge(df1, df2, on='key', validate='m:m'))
```

      key data_x data_y
    0   가      a      c
    1   가      a      e
    2   나      b      d



```python
# df1과 df2의 병합 열을 'key'로 지정하고 outer join을 할 때 양쪽 키에 중복을 허용한다.
# 'many_to_many'로 양쪽 키 모두 중복이 있어도 된다.
print(pandas.merge(df1, df2, how='outer', on='key', validate='m:m'))
```

      key data_x data_y
    0   가      a      c
    1   가      a      e
    2   나      b      d
    3   다      x    NaN
    4   라    NaN      y


# **merge** vs. **concat** vs. **join**

## **merge** 메소드

데이터프레임을 병합한다.
- 고성능 인메모리(in-memory) 조인(join) 연산을 수행한다.
- 관계형 데이터베이스의 조인(join) 연산과 유사하다. 
    + 따라서 **concat** 메소드와 달리 축과 축 이름을 기준으로 데이터를 결합하는 것이 아니라 **셀의 데이터 값을 기준으로 결합**하기 때문에 데이터베이스의 SQL과 유사하게 작동한다.
- 디폴트는 **inner join**이다.
- 데이터프레임의 **merge() 메소드**도 같은 방식으로 작동한다.
    + [pandas.DataFrame.merge](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.merge.html#pandas.DataFrame.merge)

## **concat** 메소드

데이터프레임을 결합한다. 즉, 두 개 이상의 데이터프레임을 단순히 합칠 때 사용하는 메소드다.
- pandas.**concat([DataFrame/Series1, DataFrame/Series2,...], axis='index')**
- **동종** 형태의 자료형으로 구성된 리스트나 딕셔너리 형태의 데이터프레임이나 시리즈를 받아서 이들을 결합한다.
- 오래된 시리즈/데이터프레임의 **append** 메소드보다 권장하는 방식이다.
- **concat** 메소드 /**append** 메소: 데이터의 전체 복사본을 만들어 반환하기 때문에, 이 메소드를 지속적으로 사용하면 
- 상당한 성능 저하가 발생할 수 있다는 점에 유의하자.

## **join** 메소드

인덱스 값을 기반으로 두 데이터프레임의 열들을 결합해서 하나의 데이터프레임을 만들 때는 데이터프레임의 **join** 메소드를 사용하면 편리하다.


```python
df1 = pandas.DataFrame({'key': list('가나다가라'), 
                        'ldata': [11, 12, 13, 14, 15]})

df2 = pandas.DataFrame({'key': list('나가다마다'), 
                        'rdata': [21, 22, 23, 24, 25]})

# df3은 df2와 인텍스만 다르고 나머지는 같다.
df3 = pandas.DataFrame({'key': list('나가다마다'), 
                        'rdata': [21, 22, 23, 24, 25]},
                       index=[2, 3, 4, 5, 6])
```


```python
print(df1)
```

      key  ldata
    0   가     11
    1   나     12
    2   다     13
    3   가     14
    4   라     15



```python
print(df2)
```

      key  rdata
    0   나     21
    1   가     22
    2   다     23
    3   마     24
    4   다     25



```python
print(df3)
```

      key  rdata
    2   나     21
    3   가     22
    4   다     23
    5   마     24
    6   다     25


## Inner join

**merge** 메소드의 ***how='inner'*** 는 **concat** 메소드의 ***join='inner'*** 나 **join** 메소드 의 ***how='inner'*** 와는 다르게 작동한다. 
- **concat** 메소드와 **join** 메소드는 **인덱스**로 병합을 실행한다.

### 인덱스가 같은 경우

**df1** / **df2**
<pre>
  key  ldata
0   가     11
1   나     12
2   다     13
3   가     14
4   라     15

  key  rdata
0   나     21
1   가     22
2   다     23
3   마     24
4   다     25
</pre>


```python
# --- df1과 df2의 인덱스 값이 같다.
# merge()을 사용하여 df1과 df2의 병합하는 열을 지정하지 않고 기본값(inner join)으로 병합한다.
# 이렇게 하면 같은 열 이름을 기준으로 해당 열의 같은 값을 병합(Cartesian product)한다.
print(pandas.merge(df1, df2))
```

      key  ldata  rdata
    0   가     11     22
    1   가     14     22
    2   나     12     21
    3   다     13     23
    4   다     13     25



```python
# --- df1과 df2의 인덱스 값이 같다.
# concat 메소드를 사용하여 df1과 df2의 열(컬럼)을 결합 축으로 하고 inner join으로 결합한다.
# 이렇게 하면 인덱스를 기준으로 인덱스의 같은 값을 결합한다.
print(pandas.concat([df1, df2], axis=1, join='inner'))
```

      key  ldata key  rdata
    0   가     11   나     21
    1   나     12   가     22
    2   다     13   다     23
    3   가     14   마     24
    4   라     15   다     25



```python
# --- df1과 df2의 인덱스 값이 같다.
# join을 메소드를 사용하여 df1이 df2를 inner join으로 병합하면서 
# 병합할 열 이름을 지정하지 않고 인덱스를 기준으로 인덱스의 같은 값을 결합한다.
# 같은 열 이름이 있으면 접미사(suffix)를 붙여 명칭 오류(name conflict)를 피한다.
print(df1.join(df2, how='inner', rsuffix='_right'))

# df1.join(df2, rsuffix='_right')와 같은 결과를 가진다. 또한
# pandas.concat([df1, df2], axis=1, join='inner')와 같은 결과를 가진다.
```

      key  ldata key_right  rdata
    0   가     11         나     21
    1   나     12         가     22
    2   다     13         다     23
    3   가     14         마     24
    4   라     15         다     25


### 인덱스가 다른 경우

**df1** / **df3**
<pre>
  key  ldata
0   가     11
1   나     12
2   다     13
3   가     14
4   라     15

  key  rdata
2   나     21
3   가     22
4   다     23
5   마     24
6   다     25
</pre>


```python
# --- df1과 df3의 인덱스 값이 일부는 같고 일부는 다르다.
# merge()을 사용하여 df1과 df3의 병합하는 열을 지정하지 않고 기본값(inner join)으로 병합한다.
# 이렇게 하면 같은 열 이름을 기준으로 해당 열의 같은 값을 병합(Cartesian product)한다.
# 따라서 인덱스가 달라도 상관없다. 
# 즉, pandas.merge(df1, df2)와 같은 결과를 가진다.
print(pandas.merge(df1, df3))
```

      key  ldata  rdata
    0   가     11     22
    1   가     14     22
    2   나     12     21
    3   다     13     23
    4   다     13     25



```python
# --- df1과 df3의 인덱스 값이 일부는 같고 일부는 다르다.
# concat 메소드를 사용하여 df1과 df3의 열(컬럼)을 결합 축으로 하고 inner join으로 결합한다.
# 이렇게 하면 인덱스를 기준으로 인덱스의 같은 값을 결합한다.
print(pandas.concat([df1, df3], axis=1, join='inner'))
```

      key  ldata key  rdata
    2   다     13   나     21
    3   가     14   가     22
    4   라     15   다     23



```python
# --- df1과 df3의 인덱스 값이 일부는 같고 일부는 다르다.
# join을 메소드를 사용하여 df1이 df3을 inner join으로 병합하면서 
# 병합할 열 이름을 지정하지 않고 같은 열 이름이 있으면 
# 접미사(suffix)를 붙여 명칭 오류(name conflict)를 피한다.
print(df1.join(df3, how='inner', rsuffix='_right'))

# df1.join(df2, rsuffix='_right')와 같은 결과를 가진다. 또한
# pandas.concat([df1, df3], axis=1, join='inner')와 같은 결과를 가진다.
```

      key  ldata key_right  rdata
    2   다     13         나     21
    3   가     14         가     22
    4   라     15         다     23


## Outer join

**merge** 메소드 의 ***how='outer'*** 는 **concat** 메소드의 ***join='outer'*** 나 **join** 메소드 의 ***how='outer'*** 와는 다르게 작동한다. 
- **concat** 과 **join** 의 경우는 인덱스로 병합을 실행한다.

### 인덱스가 같은 경우

**df1** / **df2**
<pre>
  key  ldata
0   가     11
1   나     12
2   다     13
3   가     14
4   라     15

  key  rdata
0   나     21
1   가     22
2   다     23
3   마     24
4   다     25
</pre>


```python
# --- df1과 df2의 인덱스 값이 같다.
# merge()을 사용하여 df1과 df2의 병합하는 열을 지정하지 않고 outer join으로 병합한다.
# 이렇게 하면 같은 열 이름을 기준으로 해당 열의 같은 값을 병합(Cartesian product)한다.
print(pandas.merge(df1, df2, how='outer'))
```

      key  ldata  rdata
    0   가   11.0   22.0
    1   가   14.0   22.0
    2   나   12.0   21.0
    3   다   13.0   23.0
    4   다   13.0   25.0
    5   라   15.0    NaN
    6   마    NaN   24.0



```python
# --- df1과 df2의 인덱스 값이 같다.
# concat 메소드를 사용하여 df1과 df2의 열(컬럼)을 결합 축으로 하고 outer join으로 결합한다.
# 이렇게 하면 인덱스를 기준으로 인덱스의 같은 값을 결합한다.
print(pandas.concat([df1, df2], axis=1))

# 이 경우 pandas.concat([df1, df2], axis=1, join='inner')과 같은 결과를 가진다.
```

      key  ldata key  rdata
    0   가     11   나     21
    1   나     12   가     22
    2   다     13   다     23
    3   가     14   마     24
    4   라     15   다     25



```python
# --- df1과 df2의 인덱스 값이 같다.
# join을 메소드를 사용하여 df1이 df2를 outer join으로 병합하면서 
# 병합할 열 이름을 지정하지 않고 인덱스를 기준으로 인덱스의 같은 값을 결합한다.
# 같은 열 이름이 있으면 접미사(suffix)를 붙여 명칭 오류(name conflict)를 피한다.
print(df1.join(df2, how='outer', rsuffix='_right'))

# df1.join(df2, rsuffix='_right')와 같은 결과를 가진다. 또한
# pandas.concat([df1, df2], axis=1)와 같은 결과를 가진다.
```

      key  ldata key_right  rdata
    0   가     11         나     21
    1   나     12         가     22
    2   다     13         다     23
    3   가     14         마     24
    4   라     15         다     25


### 인덱스가 다른 경우

**df1** / **df3**
<pre>
  key  ldata
0   가     11
1   나     12
2   다     13
3   가     14
4   라     15

  key  rdata
2   나     21
3   가     22
4   다     23
5   마     24
6   다     25
</pre>


```python
# --- df1과 df3의 인덱스 값이 일부는 같고 일부는 다르다.
# merge()을 사용하여 df1과 df3의 병합하는 열을 지정하지 않고 outer join으로 병합한다.
# 이렇게 하면 같은 열 이름을 기준으로 해당 열의 같은 값을 병합(Cartesian product)한다.
# 따라서 인덱스가 달라도 상관없다. 
# 즉, pandas.merge(df1, df2, how='outer')와 같은 결과를 가진다.
print(pandas.merge(df1, df3, how='outer'))
```

      key  ldata  rdata
    0   가   11.0   22.0
    1   가   14.0   22.0
    2   나   12.0   21.0
    3   다   13.0   23.0
    4   다   13.0   25.0
    5   라   15.0    NaN
    6   마    NaN   24.0



```python
# --- df1과 df3의 인덱스 값이 일부는 같고 일부는 다르다.
# concat 메소드를 사용하여 df1과 df3의 열(컬럼)을 결합 축으로 하고 outer join으로 결합한다.
# 이렇게 하면 인덱스를 기준으로 인덱스의 같은 값을 결합한다.
print(pandas.concat([df1, df3], axis=1))
```

       key  ldata  key  rdata
    0    가   11.0  NaN    NaN
    1    나   12.0  NaN    NaN
    2    다   13.0    나   21.0
    3    가   14.0    가   22.0
    4    라   15.0    다   23.0
    5  NaN    NaN    마   24.0
    6  NaN    NaN    다   25.0



```python
# --- df1과 df3의 인덱스 값이 일부는 같고 일부는 다르다.
# join 메소드를 사용하여 df1이 df3을 outer join으로 병합하면서 
# 병합할 열 이름을 지정하지 않고 인덱스를 기준으로 인덱스의 같은 값을 결합한다.
# 같은 열 이름이 있으면 접미사(suffix)를 붙여 명칭 오류(name conflict)를 피한다.
print(df1.join(df3, how='outer', rsuffix='_right'))

# pandas.concat([df1, df3], axis=1)와 같은 결과를 가진다.
```

       key  ldata key_right  rdata
    0    가   11.0       NaN    NaN
    1    나   12.0       NaN    NaN
    2    다   13.0         나   21.0
    3    가   14.0         가   22.0
    4    라   15.0         다   23.0
    5  NaN    NaN         마   24.0
    6  NaN    NaN         다   25.0


- - -

# THE END
